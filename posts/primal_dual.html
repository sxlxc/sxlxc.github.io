<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Primal Dual Method</title>
    <link rel="preload" href="../fonts/FiraSans-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-Italic.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/IosevkaCustom-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <link rel="stylesheet" href="../css/sidenotes.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Primal Dual Method</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on May  4, 2022
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../tags/alg.html" rel="tag">alg</a>
        
    </div>    
    <section>
        看了这本书 <a href="https://math.mit.edu/~goemans/PAPERS/book-ch4.pdf">The primal-dual
method for approximation algorithms and its application to network
design problems</a>
<h3 data-number="1" id="intro"><span class="header-section-number">1</span> intro</h3>
<p></p>
考虑一个线性规划问题
<p></p>
<span class="math display">\[
\begin{align*}
    \min \quad &amp;c^Tx\\
    s.t. \quad Ax&amp;\geq b\\
     x&amp;\geq 0
\end{align*}
\]</span>
<p></p>
他的对偶：
<p></p>
<span class="math display">\[
\begin{align*}
    \max \quad &amp;b^Ty\\
    s.t. \quad A^Ty&amp;\leq c\\
    y&amp;\geq 0
\end{align*}
\]</span>
<p></p>
根据原问题的kkt条件中的互补松弛条件（叫做对偶问题的互补松弛条件）：
<p></p>
<span class="math display">\[
y^T(Ax-b)=0
\]</span>
<p></p>
同样根据对偶问题的kkt的互补松弛条件（叫做原问题的互补松弛条件），有
<p></p>
<span class="math display">\[
x^T(A^Ty-c)=0
\]</span>
<p></p>
primal dual方法首先有一个对偶问题的可行解<span class="math inline">\(y\)</span>，如果能找到一个原问题的可行解<span class="math inline">\(x\)</span>满足互补松弛条件， 那么<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>就是原问题和对偶问题的最优解，但是<span class="math inline">\(y\)</span>如果并非最优解，就找不到可行解<span class="math inline">\(x\)</span>满足互补松弛条件。于是希望
引入一个新问题，最小化原问题可行解<span class="math inline">\(x\)</span>对互补松弛条件的违反。首先引入下标集<span class="math inline">\(I= \{ i|y_i=0 \} ,J= \{j |A^jy=c \}\)</span>，其中
<span class="math inline">\(A_i\)</span>表示<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行，<span class="math inline">\(A^j\)</span>表示<span class="math inline">\(A\)</span>的第<span class="math inline">\(j\)</span>列（写成行向量），下面是restricted
primal problems:
<p></p>
<span class="math display">\[
\begin{align*}
    \min \quad \sum_{i\notin I} s_i&amp;+\sum_{j\notin J} x_j \\
    s.t. \quad Ax_i&amp;\geq b_i &amp; i\in I\\
    \quad Ax_i-s_i&amp;= b_i &amp; i\notin I\\
    x&amp;\geq 0\\
    s&amp;\geq 0
\end{align*}
\]</span>
<p></p>
其中<span class="math inline">\(s_i(i\notin
I)\)</span>是对对偶问题的互补松弛条件的惩罚项，<span class="math inline">\(y_i\not ={0}\rightarrow A_ix=b_i\)</span>; <span class="math inline">\(x_j(j\notin
J)\)</span>是对原问题互补松弛条件的惩罚，<span class="math inline">\(A^jy\not ={c_j}\rightarrow x_j=0\)</span>;
<p></p>
如果restricted primal
problem的最优解是0，那么说明找到了原问题的一个完全满足互补松弛条件的可行解<span class="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>应该是原问题和对偶问题的最优解；
如果最优解不是0，说明<span class="math inline">\(y\)</span>并非最优解，需要改进（在例子中需要变大）。我们首先考虑restricted
primal problem的对偶：
<p></p>
<span class="math display">\[
\begin{align*}
    \max \quad &amp;b^Ty'\\
    s.t. \quad A^jy'&amp;\leq 0 &amp; j\in J\\
    A^jy'&amp;\leq 1  &amp; j\notin J\\
    y'_i&amp;\geq -1  &amp; i\notin I\\
    y'_i&amp;\geq 0   &amp; i\in I
\end{align*}
\]</span>
<hr />
<p></p>
这里得说说拉格朗日函数，kkt，线性规划对偶的关系，考虑一个线性规划问题:
<p></p>
<span class="math display">\[\begin{align*}
    \min \quad &amp;c^Tx\\
    s.t. \quad Ax&amp;\geq b\\
     x&amp;\geq 0
\end{align*}\]</span>
<p></p>
把他当成一个约束优化问题，写出拉格朗日函数：
<p></p>
<span class="math display">\[
L(x,\lambda)=c^Tx-\lambda^T(Ax-b)
\]</span>
<p></p>
<span class="math inline">\(Ax-b\geq 0\)</span>，所以有<span class="math inline">\(c^Tx\geq
L(x,\lambda)\)</span>，然后考虑拉格朗日函数的下确界：
<p></p>
<span class="math display">\[
L(x,\lambda)=\lambda^Tb-(c^T-\lambda^TA)x
\]</span>
<p></p>
如果<span class="math inline">\(c^T-\lambda^TA&gt;
0\)</span>，下界是<span class="math inline">\(-\inf\)</span>，如果<span class="math inline">\(c^T-\lambda^TA\leq 0\)</span>，下确界显然是<span class="math inline">\(\lambda^Tb\)</span>.
<p></p>
第二种情况就是线性规划的对偶问题了。<span class="math inline">\(c^Tx\geq
L(x,\lambda) \geq \lambda^Tb\)</span>
<hr />
<p></p>
继续考虑restricted primal problem的对偶，首先由于restricted primal
problem的最优解是大于0的， 上面那个对偶问题一定存在一个解<span class="math inline">\(y'&gt;0\)</span>（线性规划对偶都满足强对偶定理），利用原问题的对偶的可行解<span class="math inline">\(y\)</span> 和上面的对偶问题的可行解<span class="math inline">\(y'\)</span>构造一个新的对偶问题的可行解<span class="math inline">\(y'' =y+\epsilon
y'\)</span>，并且显然<span class="math inline">\(b^Ty''
&gt;b^Ty\)</span>，（<span class="math inline">\(\epsilon
&gt;0\)</span>）
<p></p>
这样可以得到一个更接近最优解的对偶问题可行解。
<p></p>
为了保证$y’’ $是一个对偶问题的可行解，要满足两个条件 1. <span class="math inline">\(y'' \geq 0\)</span>. 这需要<span class="math inline">\(\epsilon \leq
\min_{y'_i&lt;0}\frac{-y_i}{y'_i}\)</span> 2. <span class="math inline">\(A^Ty'' \leq c\)</span>，这需要<span class="math inline">\(\epsilon \leq
\min_{A^jy'&gt;0}\frac{c_j-A^jy}{A^jy'}\)</span>
<p></p>
得到$y’’
$之后重复上面的步骤，每次都能得到一个更接近最优解的对偶问题可行解.
<h3 data-number="2" id="an-example"><span class="header-section-number">2</span> an example</h3>
<p></p>
assignment problem (minimum-weight perfect matching problem in bipartite
graphs)
<p></p>
integer program:
<figure>
<img src="../images/primal-dual/example_IP.png" alt="example_IP" />
<figcaption aria-hidden="true">example_IP</figcaption>
</figure>
<p></p>
可以证明IP的线性松弛最优解是整数解。
<p></p>
dual of LP relaxation:
<figure>
<img src="../images/primal-dual/example_dual_LP.png" alt="example_dual_LP" />
<figcaption aria-hidden="true">example_dual_LP</figcaption>
</figure>
<p></p>
primal-dual 要从一个对偶问题的可行解开始。取<span class="math inline">\(u=v=0\)</span>
<p></p>
restricted primal:
<figure>
<img src="../images/primal-dual/rp.png" alt="rp" />
<figcaption aria-hidden="true">rp</figcaption>
</figure>
<p></p>
<span class="math inline">\(I=\emptyset,J=\{(a,b)\in E:
u_a+v_b=c_{ab}\}\)</span>
<p></p>
实际上可以证明restricted primal的基本可行解中的变量只能取0，1.
发现这是在求<span class="math inline">\(G=(A,B,J)\)</span>上的最大匹配。
<p></p>
那么对于任意一个对偶问题的解，我们都能写出restricted
primal问题，而restriced primal问题就是求一个二分图的最大匹配。
如果找到的最大匹配是一个完美匹配，可以发现restricted
primal的目标函数值为0，说明找到了最优解，否则，继续写出restricted
primal的对偶：
<figure>
<img src="../images/primal-dual/dualofrp.png" alt="dualofrp" />
<figcaption aria-hidden="true">dualofrp</figcaption>
</figure>
<p></p>
二分图上Maximum matching 的对偶实际上是 vertex cover，
在这里u取-1表示选择了这个点，取1表示没选这个点，max
u恰好是在求最小顶点覆盖
<p></p>
上面对于assignment problem
primal-dual方法给出了一个精确算法，但是过程中有两个条件难以满足： 1.
问题是由整数规划描述的，线性松弛的最优解恰好是整数解 2. 找到restricted
primal problem之后直接发现了图上的对应问题，有已知的算法来解决这个问题
<p></p>
满足不了这两个条件，得到的就是一个近似算法。
<p></p>
整数规划一般不满足强对偶定理，因此对偶问题的最优解一般与原问题最优解不相等；restricted
primal problem不一定容易解决，那么就放松互补松弛条件 &gt;the central
modification made to the primal-dual method is to enforce the primal
complementary slackness conditions and relax the dual conditions
<p></p>
primal-dual方法是对偶问题的可行解出发，看是否有能同时满足互补松弛条件和原问题约束的原问题的解，现在由于条件2无法满足，
restricted primal 及其对偶难解， 我们就只能根据 primal complementary
slackness conditions ，从对偶解来计算原问题的解，而对于dual
conditions，原问题约束有可能未被满足，有可能取等，有可能不取等，对于对偶问题变量是否取0未必有影响，因此只根据未被满足的原问题约束来想办法更新对偶解。
<p></p>
我觉得他的思路大概是这样的。
<h3 data-number="3" id="design-rules"><span class="header-section-number">3</span> design rules</h3>
<p></p>
(不是记录design rules，是想搞清楚design rules是怎么来的)
<p></p>
原问题一般都能写成这样的整数规划：
<p></p>
<span class="math display">\[
\begin{align*}
    \min \quad \sum_{e\in E}&amp;c_ex_e\\
    s.t. \quad \sum_{e\in \delta(S)}x_e&amp;\geq f(S)\\
    x_e&amp;\in \{0,1\}
\end{align*}
\]</span>
<p></p>
<span class="math inline">\(\delta(S)\)</span>是把<span class="math inline">\(V\)</span>分成<span class="math inline">\(S,V-S\)</span>的一个割，<span class="math inline">\(f(S):2^{|V|}\rightarrow \mathbf{N}\)</span>
<p></p>
书中是以hitting set problem 为例讲解的design rules，如果<span class="math inline">\(f(S):2^{|V|}\rightarrow
\{0,1\}\)</span>，那么这就是hitting set problem了
<hr />
<p></p>
hitting set problem:
<p></p>
Hitting set is an equivalent reformulation of Set
Cover.（放到二分图上，分别是选左边和选右边）
<p></p>
NP-Complete.
<p></p>
Given subsets <span class="math inline">\(T_1,\ldots,T_p\)</span> of a
ground set <span class="math inline">\(E\)</span> and given a
nonnegative cost <span class="math inline">\(c_e\)</span> for every
element in <span class="math inline">\(E\)</span>, find a minimum-cost
subset <span class="math inline">\(A\)</span> s.t. <span class="math inline">\(A\cap T_i\not ={\emptyset}\)</span> for <span class="math inline">\(i=1,\ldots,p\)</span>.
<hr />
<p></p>
hitting set problem 既然是 NP-Complete 问题，很多常见问题都能建立hitting
set的模型，上面的IP是把ground set当成图的所有割，需要hit的subsets当成
<span class="math inline">\(f(S)=1\)</span>的那些割<span class="math inline">\(\delta(S)\)</span>。
<p></p>
方便起见定义一些符号： * <span class="math inline">\(A=\{e:x_e=1\}\)</span> * <span class="math inline">\(y\)</span>: dual variable * <span class="math inline">\(T_1,\ldots,T_p\)</span> sets to be hit
<p></p>
根据part 2中的force primal complementary slackness conditions relax dual
CSCs 的方法，
<ol type="1">
<li><span class="math inline">\(y\rightarrow 0\)</span></li>
<li><span class="math inline">\(A\rightarrow \emptyset\)</span></li>
<li>While <span class="math inline">\(\exists k\)</span> : <span class="math inline">\(A\cap T_k=\emptyset\)</span></li>
<li><span class="math inline">\(\quad\)</span>Increase <span class="math inline">\(y_k\)</span> until <span class="math inline">\(\exists e\in T_k : \sum_{i:e\in T_i}
y_i=c_e\)</span></li>
<li><span class="math inline">\(\quad\)</span> <span class="math inline">\(A\rightarrow A\cup \{e\}\)</span></li>
</ol>
<p></p>
首先在<code>3</code>中，如何选择<span class="math inline">\(T_k\)</span>,如果存在多个<span class="math inline">\(T_k\)</span>怎么选？
<p></p>
这要根据问题来确定。如果找到了多个<span class="math inline">\(T_k\)</span>（称为一个violated
set），我们可以同时增加对应的对偶变量<span class="math inline">\(y_k\)</span>，直到<span class="math inline">\(\exists e\notin A : \sum_{i:e\in T_i}
y_i=c_e\)</span>.
<p></p>
由于整数规划的描述或者violation oracle可能没有严格返回<span class="math inline">\(f(S)=1\)</span>的cut等问题（比如整数规划的约束是<span class="math inline">\(\leq\)</span>，对于正权无向图的s-t最短路来说最短路一定和每个s-t
cut的交集正好都是一条边，然而换成<span class="math inline">\(\leq\)</span>会让结果 变成单源最短路），<span class="math inline">\(A\)</span>中的边可能会选的过多，去掉某些边也可能是可行解。由此可以在最后加入一个删边的过程，按照某种顺序（比如加入边的顺序）测试删掉某条边后<span class="math inline">\(A\)</span>是否 仍是可行解，如果是就删掉这条边。
<figure>
<img src="../images/primal-dual/fig4.3.jpg" alt="fig4.3" />
<figcaption aria-hidden="true">fig4.3</figcaption>
</figure>
<h3 data-number="4" id="evaluate-the-performance-guarantee"><span class="header-section-number">4</span> evaluate the performance
guarantee</h3>
<p></p>
<span class="math display">\[
\begin{align*}
    c(A)&amp;=\sum_{e\in A} c_e\\
        &amp;=\sum_{e\in A}\sum_{i:e\in T_i}y_i\\
        &amp;=\sum_{i=1}^p|A\cap T_i|y_i
\end{align*}
\]</span>
<p></p>
(2th -&gt; 3th line: exchanging the two summations)
<p></p>
令<span class="math inline">\(\alpha=\max\{|A\cap
T_i|\}\)</span>，根据<span class="math inline">\(\sum y_i\leq
OPT\)</span>容易得到
<p></p>
<span class="math display">\[
c(A)\leq \alpha OPT
\]</span>
<p></p>
这种计算近似比的方法必须要得到A之后才能算出<span class="math inline">\(\alpha\)</span>，有些不便，引入一个 minimal
augmentation set <span class="math inline">\(B\)</span>.（<span class="math inline">\(B\)</span>是<span class="math inline">\(A\)</span>加上极少数量的边从而成为一个可行解，从<span class="math inline">\(B\)</span>中去掉任何一条边都不是可行解）
由于design rules中最后删边的过程，<span class="math inline">\(|A_f\cap
T_i|\leq |B\cap T_i|\)</span>（<span class="math inline">\(A_f\)</span>是最终结果），那么对于任意当前解<span class="math inline">\(A\)</span>，我们找出对应的<span class="math inline">\(B\)</span>，分析最大的<span class="math inline">\(|B\cap T_i|\)</span>（记为<span class="math inline">\(\beta\)</span>）， <span class="math inline">\(c(A)\leq \beta OPT\)</span>。尽管minimal
augmentation set听起来很复杂，这样可以在算法的执行过程中分析。
<p></p>
再考虑design rules中的violated set. 如果考虑每次取出的violated set <span class="math inline">\(\mathcal{V}_j\)</span>，有
<p></p>
<span class="math display">\[y_i=\sum_{j:T_i\in
\mathcal{V}_j}\epsilon_j\]</span>
<p></p>
那么
<p></p>
<span class="math display">\[
\begin{align*}
    \sum_{i=1}^p y_i&amp;=\sum_{i=1}^p\sum_{j:T_i\in
\mathcal{V}_j}\epsilon_j\\
                    &amp;=\sum_{j=1}^{l} |\mathcal{V}_j|\epsilon_j
\end{align*}
\]</span>
<p></p>
<span class="math display">\[
\begin{align*}
    \sum_{i=1}^p|A_f\cap T_i|y_i&amp;=\sum_{i=1}^p|A_f\cap
T_i|\sum_{j:T_i\in \mathcal{V}_j}\epsilon_j\\
                                &amp;=\sum_{j=1}^l(\sum_{T_i\in
\mathcal{V}_j}|A_f\cap T_i|)\epsilon_j
\end{align*}
\]</span>
<p></p>
比较<span class="math inline">\(\sum_{j=1}^l(\sum_{T_i\in
\mathcal{V}_j}|A_f\cap T_i|)\epsilon_j\)</span> 和 <span class="math inline">\(\sum_{j=1}^{l} |\mathcal{V}_j|\epsilon_j\)</span>,
<p></p>
if, for all <span class="math inline">\(j\in[l]\)</span>,
<p></p>
<span class="math display">\[
\sum_{i=1}^p |A_f\cap T_i|\leq \gamma|\mathcal{V}_j|
\]</span>
<p></p>
then
<p></p>
<span class="math display">\[
\begin{align}
    \sum_{i=1}^p|A_f\cap T_i|y_i&amp;=\sum_{i=1}^p|A_f\cap
T_i|\sum_{j:T_i\in \mathcal{V}_j}\epsilon_j\\
                                &amp;=\sum_{j=1}^l(\sum_{T_i\in
\mathcal{V}_j}|A_f\cap T_i|)\epsilon_j\\
                                &amp;\leq
\sum_{j=1}^l\gamma|\mathcal{V}_j|\epsilon_j\\
                                &amp;=\gamma\sum_{i=1}^p y_i
\end{align}
\]</span>
<p></p>
这还是需要先计算出<span class="math inline">\(A_f\)</span>，现在结合上minimal augmentation set
<span class="math inline">\(B\)</span>，
<p></p>
<span class="math display">\[
\sum_{i=1}^p |A_f\cap T_i|\leq \sum_{T_i\in \mathcal{V}(A)}|B\cap T_i|
\leq \gamma|\mathcal{V}_j|
\]</span>
<p></p>
同上，<span class="math inline">\(\gamma\)</span>就是近似比。
<p></p>
再进一步考虑如果violation oracle返回的<span class="math inline">\(\mathcal{V}\)</span>中有<span class="math inline">\(f(S)=0\)</span>的cut，那么与上文类似，
<p></p>
<span class="math display">\[
\sum_{T_i\in \mathcal{V}(A)}|B\cap T_i| \leq \gamma c
\]</span>
<p></p>
<span class="math inline">\(c\)</span>是<span class="math inline">\(\mathcal{V}(A)\)</span>中<span class="math inline">\(f(S)=1\)</span>的cut的数量。
<p></p>
design rules 并不是一定最优，只是对于某些问题这样做挺好，对于这些design
rules 现在都有办法通过分析设计出的近似算法的过程来确定近似比了。
<h3 data-number="5" id="notes"><span class="header-section-number">5</span> notes</h3>
<p></p>
后来在读 the design of approximation algorithms 中的 chap 7.
<p></p>
首先Theorem 7.1的定理<span class="math inline">\(f=\max{|\{j:e_i\in
S_j\}|}\)</span>是近似比，就是part3 中的 evaluate the performance
guarantee 部分第一个定理（参数是<span class="math inline">\(\alpha\)</span>那个）
<p></p>
对于part2中说到的近似算法放松互补松弛条件（CSC），这里又更详细的解释： -
enforce primal CSC 意味着如果<span class="math inline">\(x_i&gt;0\)</span>，<span class="math inline">\(x_i\)</span>在对偶问题里对应的不等式取等。 - relax
dual CSC 如果某个对偶变量<span class="math inline">\(y_i&gt;0\)</span>，在原问题里对应的约束不等式却未必取等。
<p></p>
求近似比的部分中<span class="math inline">\(f=\max{|\{j:e_i\in
S_j\}|}=\sum_{j:e_i\in S_j}x_j\)</span> 也就是<span class="math inline">\(y_i&gt;0\)</span>在原问题中对应的约束不等式左侧。
<p></p>
因此 relax dual CSC 保证了近似比，而 enforce primal CSC
提供了通过对偶构造原问题可行解的方法。
<hr />
<p></p>
整数规划的对偶应该是什么样的？对于同一个问题，不同的整数规划建模的对偶最优解都相同吗？
<p></p>
整数规划没有严格意义上的对偶，但是有个叫拉格朗日对偶的东西。
<p></p>
对于同一个问题不同整数规划建模对偶的最优解是不一样的，不同建模的线性松弛最优解都不一样。
<p></p>
拉格朗日对偶大概是这样的东西：（看了知乎上某人的integer
programming翻译，我推了一下，但基本上变成latex公式输入练习了。。。）
part1中有一点拉格朗日函数和对偶的部分，那里用的原问题是一个线性规划，
把他变成整数规划，加入一个<span class="math inline">\(x\in X\subset
Z\)</span>的约束，然后求<span class="math inline">\(\max_{\lambda}\min_{x}\lambda^Tb-(c^T-\lambda^TA)x\)</span>
（在<span class="math inline">\(x\in X\subset
Z\)</span>的约束下）实际上也就是通过调整<span class="math inline">\(\lambda\)</span>，让拉格朗日函数的下确界尽量大。
<p></p>
我总觉得这里拉格朗日函数的最小值就是原来的整数规划最优解，但是实际上不是，拉格朗日函数已经是原问题的松弛了，因为在拉格朗日函数中，扔掉了<span class="math inline">\(Ax-b\geq 0\)</span>这个
约束，后面的过程根本没有考虑过<span class="math inline">\(Ax-b\geq
0\)</span>这个约束
<p></p>
IP:
<p></p>
<span class="math display">\[
\begin{align*}
    \min \quad &amp;c^Tx\\
    s.t. \quad Ax&amp;\geq b\\
     x&amp;\geq 0\\
     x&amp;\in Z
\end{align*}
\]</span>
<p></p>
构造<span class="math inline">\(f(x)=c^Tx-\mu^T(Ax-b)\leq
c^Tx\)</span>(let <span class="math inline">\(\mu\leq 0\)</span>)
<p></p>
<span class="math inline">\(f(x)\)</span>的下确界尽量大：<span class="math inline">\(g(\mu)=\max_{\mu}\min_{x}(c^T-\mu^TA)x+\mu^Tb\)</span>
<p></p>
写成线性规划的形式：
<p></p>
<span class="math display">\[
\begin{align*}
    \min \quad &amp;\eta\\
    s.t. \quad
    (c^T-\mu^TA)x_1+\mu^Tb&amp;\geq \eta\\
    (c^T-\mu^TA)x_2+\mu^Tb&amp;\geq \eta\\
    &amp;\ldots\\
    (c^T-\mu^TA)x_n+\mu^Tb&amp;\geq \eta\\
    \mu &amp;\geq 0\\
    \eta &amp;\in R
\end{align*}
\]</span>
<p></p>
然后写出上面的线性规划的对偶：
<p></p>
<span class="math display">\[
\begin{align*}
    \min \quad \sum_{i=1}^n \lambda_i(c^Tx_i)&amp;\\
    s.t. \quad
    \sum_{i=1}^n \lambda_i (Ax_i-b)&amp;\geq 0\\
    \sum_{i=1}^n \lambda_i &amp;= 1\\
    \lambda &amp;\geq 0
\end{align*}
\]</span>
<p></p>
把此处的<span class="math inline">\(x_i\in Z\)</span>放大为<span class="math inline">\(x_i\in R\)</span>, 由于<span class="math inline">\(x_i\in R, x_i\geq 0\)</span>是凸集，所以<span class="math inline">\(x=\sum_{i=1}^n \lambda_i x_i\in
R\)</span>，上面的对偶可以直接改写为整数规划的线性松弛。
<p></p>
这说明了通过调整乘子来让拉格朗日函数的下确界最大的这种这种方法获得的解要比线性松弛的解更好，因为上面有一个把<span class="math inline">\(x\in Z\)</span>放大到<span class="math inline">\(x\in R\)</span>的过程。
<p></p>
然后我就发现了一个问题，观察<span class="math inline">\(g(\mu)=\max_{\mu}\min_{x}(c^T-\mu^TA)x+\mu^Tb\)</span>，发现如果取某个<span class="math inline">\(\mu\)</span>使得<span class="math inline">\(c^T-\mu^TA\)</span>的某一项是小于0的， 由于<span class="math inline">\(x\)</span>在这里的范围是<span class="math inline">\(0\leq x \in Z\)</span>，为了取到<span class="math inline">\(\min\)</span>，<span class="math inline">\(x\)</span>对应分量就会取正无穷，那么下确界也就是负无穷了，无法得到一个有效的对偶，因此
取<span class="math inline">\(\mu\)</span>必须满足<span class="math inline">\((c^T-\mu^TA)\geq 0\)</span>，这样一来<span class="math inline">\(x\)</span>一定会取到<span class="math inline">\(\mathbf{0}\)</span>，下确界也就是<span class="math inline">\(\mu^Tb\)</span>，写成一个线性规划问题竟然和原来的整数规划的
线性松弛的对偶一样，但是根据刚刚的证明拉格朗日函数下确界的这种方法应该比线性松弛获得的解更好。
<p></p>
我觉得问题在于：上一段的简单分析应该是没有错误的，这也是为什么 integer
programming 中讲拉格朗日对偶只是把一部分约束放入函数中。在处理的过程中，
<span class="math inline">\(Ax-b\)</span>被扔到了目标函数里面去，而<span class="math inline">\(x\)</span>的取值范围并没有保证<span class="math inline">\(Ax-b\geq
0\)</span>。实际上如果把所有约束都放到目标函数内的话拉格朗日对偶就是和线性松弛的对偶一样的。
观察上面<span class="math inline">\(x_i\in Z\)</span>放大为<span class="math inline">\(x_i\in R\)</span>的部分，实际上<span class="math inline">\(x_i\)</span>是各个分量大于等于0的所有n维整数向量，他们构成的凸包和<span class="math inline">\(x_i\in R\)</span>构成的完全一样。
<hr />
<h3 data-number="6" id="random-thoughts"><span class="header-section-number">6</span> random thoughts</h3>
<p></p>
从寒假开始也算是看了两本书关于 primal-dual 方法的章节。
<p></p>
大多数问题的建模都是整数规划，primal-dual
用的是线性松弛的对偶，找到的可行解也不会比线性松弛的最优解更好，
只有线性松弛的解和整数规划相比比较接近才有很好的近似比，如果像是
feedback vertex set 用hitting
set建模的整数规划，这种线性松弛最优解近似比是logn级别，
primal-dual近似比最好也只能做到logn级别了，但是最短路的hitting
set建模线性松弛最优解和整数规划最优解相等，primal-dual甚至能得出精确算法（dijkstra），
同样的问题，不同的整数规划建模方法，就有不同的线性松弛，就有不同的近似比。
<p></p>
为什么不直接解线性松弛而要用primal-dual？我觉得主要原因是原来的整数规划约束个数可能是指数级别，解线性规划会解不出，
但是primal-dual有时候（Violation
Oracle能很快给出还没满足的约束）需要维护的对偶变量数量只是多项式级别的。
<p></p>
要用primal-dual方法解决一个问题，需要考虑 -
用什么方法来写出整数规划，是否能找出一个能用的Violation
Oracle，线性松弛是否有一个好的近似比 - 根据具体问题是否有好用的design
rules，按照什么方法和顺序找violated set等，复杂度又如何 -
怎么分析近似比，能不能做到线性松弛的近似比一样的级别
<p></p>
我发现大概这个整数规划约束有指数多个，一般整数规划和线性松弛差的不大。
<p></p>
对比The primal-dual method for approximation algorithms and its
application to network design problems, chapter 4这个章节和The Design of
Approximation Algorithms chapter 7，
明显后者更加简单易懂，使用了很多例子，但是我觉得前者要系统很多，而且更加符合逻辑和直觉。首先介绍什么是classic
primal-dual
method，从这个方法出发有了设计近似算法的基本框架，如何从整数规划的线性松弛和LP的对偶
找到原问题（IP）的可行解，以及后面对用hitting set建模抽象出来的函数<span class="math inline">\(f(S)\)</span>的讨论，而后者通过众多例子介绍了primal-dual，比较易懂，但是关键部分的近似比证明受例子的影响，没有一般化，感觉很难想到。
<p></p>
根据之前看的两本书，做了<a href="../pdfs/primal-dual_method.pdf">slides</a>.
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>