<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Collecting pebbles and (hyper)graph sparsity</title>
    <link rel="stylesheet" href="../../css/fonts.css" />
    <link rel="stylesheet" href="../../css/default.css" />
    <link rel="stylesheet" href="../../css/pygentize.css" />
    <link rel="stylesheet" href="../../css/chao-theorems.css">
    <link rel="stylesheet" href="../../css/sidenotes.css">
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });
        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontPath: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../../">Home</a>
                <div class="navright">
                    <a href="../../draft">Drafts</a>
                    <a href="../../about">About</a>
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Collecting pebbles and (hyper)graph sparsity</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on March 11, 2024
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../../tags/alg/index.html" rel="tag">alg</a>, <a title="All pages tagged 'sage'." href="../../tags/sage/index.html" rel="tag">sage</a>, <a title="All pages tagged 'combinatorics'." href="../../tags/combinatorics/index.html" rel="tag">combinatorics</a>
        
    </div>    
    <section class="body">
        <blockquote>
<p></p>
assuming familiarity with basic matroid thoery
</blockquote>
<p></p>
<strong>Problem</strong> collecting pebbles. Given a directed graph
<span class="math inline">\(G=(V,E)\)</span>. There are pebbles on a
subset of vertives <span class="math inline">\(T\subset V\)</span>. We
can move pebbles along the directed edges. Once we move a pebble along
some edge, this edge is immediately inverted. The problem is can we move
<span class="math inline">\(k\)</span> pebbles to a special vertex <span class="math inline">\(s\)</span>.
<p></p>
I think this should be NP-Hard but I don‚Äôt know how to prove it.
<p></p>
I found this problem in a paper <a href="https://linkinghub.elsevier.com/retrieve/pii/S0012365X07005602">‚ÄúPebble
game algorithms and sparse graphs‚Äù</a>. On <span class="math inline">\((k,\ell)\)</span>-sparse graphs with special rules
for putting initial pebbles this problem can be solved through simple
depth-first-search.
<p></p>
There are two interesting ideas in the paper. The relation of sparsity
and pebble games and why the above problem can be solved with simple
dfs.
<h3 data-number="1" id="kell-sparsity"><span class="header-section-number">1</span> <span class="math inline">\((k,\ell)\)</span>-sparsity</h3>
<p></p>
<span class="math inline">\((k,\ell)\)</span>-sparsity is a quantitative
way to say how sparse an undirected graph is. <span class="math inline">\(k,\ell\in \mathop{\mathrm{\mathbb{Z}}}_+\)</span>
and <span class="math inline">\(\ell \leq 2k-1\)</span>. A graph <span class="math inline">\(G\)</span> is <span class="math inline">\((k,\ell)\)</span>-sparse if <span class="math inline">\(|E|\leq k|V|-\ell\)</span> holds for any subgraph
<span class="math inline">\(H=(V,E)\)</span> of <span class="math inline">\(G\)</span>. One can see that <span class="math inline">\(\ell \leq 2k-1\)</span> since otherwise there must
be no edge between any two vertices. The <span class="math inline">\((k,\ell)\)</span>-sparse subgraphs(edge set) of
<span class="math inline">\(G\)</span> form the independent sets of a
matroid. For more on matroid and especially sparsity matroid, read <a href="https://en.wikipedia.org/wiki/Matroid">matroid</a> and <a href="https://en.wikipedia.org/wiki/Sparsity_matroid">sparsity
matroid</a>. The <code>Pairs (k,l) that form a matroid</code> part in
the sparsity matroid link is misleading. Matroids with <span class="math inline">\(k,l\)</span> and <span class="math inline">\(n\)</span> satisfying those condition will have a
spanning tight graph as their bases; those who don‚Äôt satisfying
conditions are still matroids but their bases will never be <span class="math inline">\((k,\ell)\)</span>-tight graphs.
<p></p>
Actually more general things are also matroids. They are called count
matroids. read Andras Frank‚Äôs <a href="http://scholar.google.com/scholar?hl=en&amp;btnG=Search&amp;q=intitle:Connections+in+Combinatorial+Optimization#0">‚ÄúConnections
in Combinatorial Optimization‚Äù</a> Theorem 13.5.5 for proofs.
<p></p>
In terms of sparsity, the proof in the book basically shows <span class="math inline">\(r(F)=k|V(F)|-l\)</span> is a matroid rank function
and the independnet sets of our sparsity matroid defined above are
exactly the independent sets of the matroid defined by rank function
<span class="math inline">\(r\)</span>.
<p></p>
If you want to prove the independnet set exchange property directed, it
seems a little harder. We need to show for any two <span class="math inline">\((k,\ell)\)</span>-sparse subgraph <span class="math inline">\((V_1,I_1)\)</span> and <span class="math inline">\((V_2,I_2)\)</span> s.t. <span class="math inline">\(|I_1|&gt;|I_2|\)</span>, there exists <span class="math inline">\(e\in I_1\setminus I_2\)</span> s.t. <span class="math inline">\(I_2\cup \{e\}\)</span> is <span class="math inline">\((k,\ell)\)</span>-sparse. We only consider
connnected graphs. If <span class="math inline">\(V(I_1)\)</span> is not
a subset of <span class="math inline">\(V(I_2)\)</span>, there would be
<span class="math inline">\(u\in V(I_1)\)</span> and some edge <span class="math inline">\(e\)</span> connecting <span class="math inline">\(u\)</span> and <span class="math inline">\(V(I_2)\)</span>. <span class="math inline">\(e\)</span> can be added to <span class="math inline">\(I_2\)</span> since <span class="math inline">\(k\geq 1\)</span>. On the other hand if <span class="math inline">\(V(I_1)\)</span> is a subset of <span class="math inline">\(V(I_2)\)</span> how to find such an edge? Suppose
such an edge does not exist. Then for any <span class="math inline">\(e=(u,v)\in I_1\setminus I_2\)</span>, we can find
a tight subgraph <span class="math inline">\(H=(V',E')\)</span>
of <span class="math inline">\(I_2\)</span> containing <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> but not the edge <span class="math inline">\(e\)</span>.(see Theorem 5 in the pebble game
paper). Also there exists at least one edge in <span class="math inline">\(E'\)</span> but not in <span class="math inline">\(I_1\)</span>. <del>(I think the contradiction is
<span class="math inline">\(|I_2|\geq |I_1|\)</span> but don‚Äôt know what
to do next‚Ä¶)</del> This method doesn‚Äôt work
<figure>
<img src="../../images/pebblegame/klsparseproof.png" alt="sparsity proofs" />
<figcaption aria-hidden="true">sparsity proofs</figcaption>
</figure>
<p></p>
Googling ‚Äògraph sparsity‚Äô normally returns sparsity measurement like
upperbounds on average degree or max degree. There are many literature
about bounded max(average) vertex degree graphs(see <a href="https://www.mimuw.edu.pl/~mp248287/sparsity2/">this lecture from
mim_uw</a> for example). However these definitions don‚Äôt imply matroids.
For example graph with max degree 4.
<figure>
<img src="../../images/pebblegame/ce.jpeg" alt="counterexample" />
<figcaption aria-hidden="true">counterexample</figcaption>
</figure>
<p></p>
One can see that the two graphs do not satisfy the independent set
exchange property.
<h3 data-number="2" id="pebble-game"><span class="header-section-number">2</span> pebble game</h3>
<p></p>
How to decide whether a given graph is <span class="math inline">\((k,\ell)\)</span>-sparse? <a href="https://linkinghub.elsevier.com/retrieve/pii/S0012365X07005602">‚ÄúPebble
game algorithms and sparse graphs‚Äù</a> provides an algorithm solving the
problem in polynomial time(<span class="math inline">\(O(n^2)\)</span>,<span class="math inline">\(n\)</span> is the number of vertices) and a proof
of equivalence of pebble game and graph <span class="math inline">\((k,\ell)\)</span>-sparsity.
<p></p>
The algorithm described in the paper basically finds a base of <span class="math inline">\((k,\ell)\)</span>-sparsity matorid defined on the
input graph. Note that finding a base of any matroid <span class="math inline">\(\mathcal{M}=(E,\mathcal{I})\)</span> can be easily
done with <span class="math inline">\(O(|E|)\)</span> independence
oracle calls. If we want a polynomial time alg then the independence
oracle must be fast. A bruteforce method is to check every subgraph. We
can certainly not afford that.
<p></p>
In the paper the authors designed a nice way to check independence. The
idea is instead of comparing <span class="math inline">\(k|V|-\ell\)</span> and <span class="math inline">\(|E|\)</span>, they compare <span class="math inline">\(k|V|-|E|\)</span> and <span class="math inline">\(\ell\)</span>. Then <span class="math inline">\(\ell\)</span> is fixed and checking every subgraph
to compute <span class="math inline">\(k|V|-|E|\)</span> is still
needed. They manage to count <span class="math inline">\(k|V|-|E|\)</span> by counting pebbles on vertices
instead of counting edges. Thus the rules of pebble games are quite
straightforward(but still some ambiguous rules). Initially we have an
empty graph and <span class="math inline">\(n\)</span> vertices. On each
vertex there are <span class="math inline">\(k\)</span> pebbles(for
<span class="math inline">\(k|V|\)</span>). We consider edges one by one
in arbitrary order. Once we added an edge to the graph, we should remove
one pebble from one of the edge‚Äôs endpoints. We need to design rules for
accepting or rejecting edges. Astute readers may find that simply
removing pebbles while adding new edges is completely not working üòÖ. We
want the remaining pebbles on any subgraph to be <span class="math inline">\(k|V|-|E|\)</span> but the method we try to use
doesn‚Äôt guarantee this since we may remove a pebble on either endpoint
of the added edge‚Ä¶
<p></p>
In the paper they use directed graph. When considering an undirected
edge <span class="math inline">\((u,v)\)</span>, they make it
directed(i.e.¬†<span class="math inline">\(u\rightarrow v\)</span>) and
then remove a pebble from the source(<span class="math inline">\(u\)</span>). An edge is accepted if and only the
endpoints can collect <span class="math inline">\(l+1\)</span> pebbles
in total. Collecting pebbles is just searching paths from <span class="math inline">\(u\)</span> or <span class="math inline">\(v\)</span> to some vertex with pebbles and moving
one pebble from that vertex to <span class="math inline">\(u\)</span>(or
<span class="math inline">\(v\)</span>) and reversing the edges on the
path. For any vertex, if an out edge is added, an pebble is
removed(accepting edge); if one pebble is removed, an out edge is
added(pebble collecting vertex); if one pebble is added, one out edge is
removed(reverse pebble collecting path).
<p></p>
One can see that for any subgraph <span class="math inline">\(G'=(V',E')\)</span> this pebble
collection and edge adding operation preserve the sum of
<ol type="1">
<li>total number of pebbles on <span class="math inline">\(V'\)</span></li>
<li><span class="math inline">\(|E'|\)</span></li>
<li><span class="math inline">\(\delta_{\text{out}}(V')\)</span>.</li>
</ol>
<p></p>
see the paper for detailed proof.
<figure>
<img src="../../images/pebblegame/invariant.png" alt="proof in the paper" />
<figcaption aria-hidden="true">proof in the paper</figcaption>
</figure>
<p></p>
The last question is can we do every operations in polynomial time? or
in other words why collecting pebbles can be done in polynomial time? In
the paper there is a lemma saying that if adding an edge <span class="math inline">\((u,v)\)</span> does not break sparsity and there
are not enough pebbles on <span class="math inline">\(u\)</span> and
<span class="math inline">\(v\)</span>(we need to do pebble collection),
then we can always find a pebble collecting path without changing the
pebble count of other vertices. Thus we can collect pebbles by simple
dfs.
<p></p>
python code for hypergraph sparsity.
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx <span class="im">import</span> Graph</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> chain, combinations</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">pebble game algorithm for checking hypergraph sparsity.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">`hyperedges` is a list of frozensets of non-number objects.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">for example, `[frozenset({'1', '0'})]`</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pebblegame(k,l,hyperedges:<span class="bu">list</span>):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    vertices<span class="op">=</span><span class="bu">frozenset</span>().union(<span class="op">*</span>hyperedges)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span><span class="bu">len</span>(vertices)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    pebs<span class="op">=</span>{v:k <span class="cf">for</span> v <span class="kw">in</span> vertices}</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    H_tail<span class="op">=</span>Graph()</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    H_tail.add_nodes_from(<span class="bu">range</span>(<span class="bu">len</span>(hyperedges)),bipartite<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    H_tail.add_nodes_from(vertices,bipartite<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_edge(i):</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        H<span class="op">=</span>hyperedges[i]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        v<span class="op">=</span><span class="bu">next</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> v:pebs[v]<span class="op">&gt;</span><span class="dv">0</span>,H))</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        pebs[v]<span class="op">=</span>pebs[v]<span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        H_tail.add_edge(i,v)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> collect_pebble(v,forbiddenset): <span class="co"># collect 1 peb to v.</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">=</span><span class="bu">set</span>()</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        path<span class="op">=</span>[]</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># use dfs to collect pebs</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> dfs(node,node_H):</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node <span class="kw">in</span> visited: <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># don't use nodes in H</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node_H <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> node <span class="kw">in</span> forbiddenset: </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            visited.add(node)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            path.append((node,node_H))</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node <span class="kw">not</span> <span class="kw">in</span> forbiddenset <span class="kw">and</span> pebs[node]<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                <span class="co"># pebs[node]=pebs[node]-1</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>                <span class="co"># pebs[v]=pebs[v]+1</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> H <span class="kw">in</span> H_tail.neighbors(node):</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> nxt <span class="kw">in</span> hyperedges[H]:</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> nxt<span class="op">!=</span>node <span class="kw">and</span> dfs(nxt,H): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            path.pop()</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dfs(v,<span class="op">-</span><span class="dv">1</span>):  <span class="co"># find a pebble</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>            <span class="co"># collect the pebble</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>            t,_<span class="op">=</span>path[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            pebs[t]<span class="op">=</span>pebs[t]<span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            pebs[v]<span class="op">=</span>pebs[v]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            <span class="co"># reverse hyperedges</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>            last_u,last_H<span class="op">=</span>path.pop()</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="bu">len</span>(path):</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>                top_u,top_H<span class="op">=</span>path.pop()</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>                H_tail.remove_edge(last_H,top_u)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>                H_tail.add_edge(last_H,last_u)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>                last_u,last_H<span class="op">=</span>top_u,top_H</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:   <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># try to add every hyperedge</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(hyperedges)):</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        H<span class="op">=</span>hyperedges[i]</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        demand<span class="op">=</span>l<span class="op">+</span><span class="dv">1</span><span class="op">-</span><span class="bu">sum</span>([pebs[v] <span class="cf">for</span> v <span class="kw">in</span> H])</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> demand<span class="op">&lt;=</span><span class="dv">0</span>: add_edge(i)</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:   <span class="co"># collect pebs</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>                collected<span class="op">=</span><span class="va">False</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> u <span class="kw">in</span> H:</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> H_tail.degree(u)<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> collect_pebble(u,forbiddenset<span class="op">=</span>H):</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>                            demand<span class="op">=</span>demand<span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>                            collected<span class="op">=</span><span class="va">True</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> demand<span class="op">==</span><span class="dv">0</span>: </span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">break</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> collected:   <span class="co"># can not add this edge</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="st">&quot;dependent&quot;</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> demand<span class="op">==</span><span class="dv">0</span>: <span class="cf">break</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            add_edge(i)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">sum</span>([pebs[v] <span class="cf">for</span> v <span class="kw">in</span> vertices])<span class="op">==</span>l: <span class="cf">return</span> <span class="st">&quot;tight&quot;</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">return</span> <span class="st">&quot;sparse&quot;</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="co"># # tests</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="co"># import random</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="co"># def bruteforce(k,l,hyperedges):</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="co">#     def non_empty_subsets(s):</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a><span class="co">#         return list(chain.from_iterable(combinations(s, r) </span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a><span class="co">#                                         for r in range(1, len(s) + 1)))</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a><span class="co">#     for U in non_empty_subsets(hyperedges):</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="co">#         vertices=frozenset().union(*U)</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="co">#         if len(vertices)*k-l&lt;len(U):</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="co">#             return &quot;dependent&quot;</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="co">#     return &quot;sparse&quot;</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a><span class="co"># def generate_random_subsets(n, k):</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="co">#     # Define the set [n]</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="co">#     full_set = list(range(1, n + 1))</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="co">#     # Generate k random subsets</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="co">#     subsets = []</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a><span class="co">#     for _ in range(k):</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="co">#         # Randomly choose a subset size</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="co">#         subset_size = random.randint(1, n)</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a><span class="co">#         # Randomly select subset_size elements from the set</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="co">#         subset = random.sample(full_set, subset_size)</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a><span class="co">#         subsets.append(frozenset(map(str,subset)))</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="co">#     return subsets</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="co"># while True:</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="co">#     n_v=100</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="co">#     n_H=10</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="co">#     k=2</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a><span class="co">#     l=2</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="co">#     hyperedges=generate_random_subsets(n_v,n_H)</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="co">#     pebble_res=pebblegame(k,l,hyperedges)</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a><span class="co">#     bf_res=bruteforce(k,l,hyperedges)</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(pebble_res,bf_res)</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a><span class="co">#     if pebble_res!=bf_res:</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a><span class="co">#         print(hyperedges)</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="co">#         input()</span></span></code></pre></div>
<p></p>
sage code for an straightforward <span class="math inline">\(O(n^3)\)</span> implementation
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_kl_sparse(g,k:<span class="bu">int</span>,l:<span class="bu">int</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">r'''</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    pebble game algorithm for deciding if `g` is (k,l)-sparse.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    `g` may have multiedges and loops</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    use `g=Graph(multiedges=True,loops=True)` from sagemath graph</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    https://linkinghub.elsevier.com/retrieve/pii/S0012365X07005602</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span>(k<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> l<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> l<span class="op">&lt;=</span><span class="dv">2</span><span class="op">*</span>k<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    d<span class="op">=</span>DiGraph(multiedges<span class="op">=</span><span class="va">True</span>,loops<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    d.add_vertices(g.vertex_iterator())</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    peb<span class="op">=</span>[k <span class="cf">for</span> _ <span class="kw">in</span> d.vertex_iterator()]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">=</span>g.edges(labels<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(u,v): <span class="co"># returns if u can get pebble. dfs should not touch v</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        vis<span class="op">=</span>[<span class="va">False</span> <span class="cf">for</span> _ <span class="kw">in</span> d.vertex_iterator()]</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        pre<span class="op">=</span>[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> _ <span class="kw">in</span> d.vertex_iterator()]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        st<span class="op">=</span>[]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        vis[u]<span class="op">=</span>vis[v]<span class="op">=</span><span class="va">True</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        st.append(u)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(st):</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            h<span class="op">=</span>st.pop()</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(peb[h]<span class="op">&gt;</span><span class="dv">0</span>):</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                peb[h]<span class="op">=</span>peb[h]<span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> pre[h]<span class="op">!=-</span><span class="dv">1</span>:</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>                    d.reverse_edge((pre[h],h))</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                    h<span class="op">=</span>pre[h]</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                peb[h]<span class="op">=</span>peb[h]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> c <span class="kw">in</span> d.neighbor_out_iterator(h):</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> vis[c]:</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                    vis[c]<span class="op">=</span><span class="va">True</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                    st.append(c)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                    pre[c]<span class="op">=</span>h</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> edgeinsertion(u,v):</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> peb[u]<span class="op">==</span><span class="dv">0</span>: u,v<span class="op">=</span>v,u</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        d.add_edge(u,v)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        peb[u]<span class="op">=</span>peb[u]<span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    rej<span class="op">=</span><span class="dv">0</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (u,v) <span class="kw">in</span> edges:</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> peb[u]<span class="op">+</span>peb[v]<span class="op">&gt;=</span>l<span class="op">+</span><span class="dv">1</span>:</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            edgeinsertion(u,v)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>                tryu<span class="op">=</span>tryv<span class="op">=</span><span class="va">False</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> peb[u]<span class="op">&lt;</span>k: tryu<span class="op">=</span>dfs(u,v)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> peb[u]<span class="op">+</span>peb[v]<span class="op">==</span>l<span class="op">+</span><span class="dv">1</span>:</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>                    edgeinsertion(u,v)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> peb[v]<span class="op">&lt;</span>k: tryv<span class="op">=</span>dfs(v,u)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> peb[u]<span class="op">+</span>peb[v]<span class="op">==</span>l<span class="op">+</span><span class="dv">1</span>:</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>                    edgeinsertion(u,v)</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> tryu <span class="kw">and</span> <span class="kw">not</span> tryv:</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>                    rej<span class="op">=</span>rej<span class="op">+</span><span class="dv">1</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># d.plot().show()</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># input()</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    pebsum<span class="op">=</span><span class="bu">sum</span>(peb)</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pebsum<span class="op">==</span>l:</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> rej<span class="op">==</span><span class="dv">0</span>: <span class="cf">return</span> <span class="st">&quot;tight&quot;</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="cf">return</span> <span class="st">&quot;spanning&quot;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> pebsum<span class="op">&gt;</span>l <span class="kw">and</span> rej<span class="op">==</span><span class="dv">0</span>: <span class="cf">return</span> <span class="st">&quot;sparse&quot;</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="cf">return</span> <span class="st">&quot;other&quot;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a><span class="co"># d=Graph(multiedges=True,loops=True)</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a><span class="co"># d.add_edges([(0,2),(1,2),(1,3),(2,4),(2,5),(4,6),(4,7),(5,8)])</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a><span class="co"># # d.plot().show()</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a><span class="co"># # print(is_kl_sparse(d,1,1))</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a><span class="co"># d.add_edge(4,6)</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="co"># d.plot().show()</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="co"># print(is_kl_sparse(d,1,1))</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="co"># print(sum(peb))</span></span></code></pre></div>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>