<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>什么样的核函数可以用于非参数估计?</title>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <link rel="stylesheet" href="../css/sidenotes.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontPath: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">什么样的核函数可以用于非参数估计?</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on September  8, 2022
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'statistics'." href="../tags/statistics.html" rel="tag">statistics</a>
        
    </div>    
    <section>
        <blockquote>
<p></p>
2022 在计量2课上想的问题
</blockquote>
<h2 data-number="1" id="原理"><span class="header-section-number">1</span> 原理</h2>
<p></p>
想用非参数方法估计一个连续型随机变量的 pdf, 目前有样本 <span class="math inline">\(x_1,\ldots, x_n\)</span>.
<p></p>
从连续型随机变量的pdf定义出发, 是概率分布函数的导数, <span class="math inline">\(\lim_{h\to 0}\frac{F(x+h)-F(x-h)}{2h}\)</span> ,
于是我们用这个式子来估计pdf.
<p></p>
<span class="math display">\[
PDF(x) = \frac{1}{2nh}\sum_{i=1}^n \mathbb{I}(\frac{x_i-x}{h}\leq 1)
\]</span>
<p></p>
然后随便找点损失函数，用数值方法优化一下h，这样可以得到pdf的一个非参数估计
<p></p>
根据pdf的定义，h是应该趋于0的，那么上式中h该取0，但是由于样本数量有限，是抽样得来的，所以不能这样做。那么很自然的想到，在x的h邻域内的这些点也不应该有相同的权值，越靠近x对我估计的pdf的贡献应该越大，课程上这样引入了其他核函数。
<p></p>
上面使用的核函数就是简单的指示函数 <span class="math inline">\(\mathbb{I}(\frac{x_i-x}{h}\leq 1)\)</span> 在<span class="math inline">\(x_i\)</span>于<span class="math inline">\(x\)</span>距离不超过<span class="math inline">\(h\)</span>时为1，其他为0. 新的核函数要让<span class="math inline">\(x_i\)</span>于<span class="math inline">\(x\)</span>距离不超过<span class="math inline">\(h\)</span>时越靠近<span class="math inline">\(x\)</span>权值越高，远离x权值就低。
<h2 data-number="2" id="问题"><span class="header-section-number">2</span> 问题</h2>
<p></p>
现在产生了两个问题： 1.
核函数是分段函数，把上面估计pdf的式子中的指示函数换成其他分段的核函数也会让产生的pdf有很多不可导的点，能否直接<span class="math inline">\(x_i\)</span>于<span class="math inline">\(x\)</span>距离不超过<span class="math inline">\(h\)</span>这个限制，通过核函数直接加权。比如核函数为标准正态分布pdf，核函数不分段，最后生成的一定是一个处处可导的pdf。
2. 什么样的核函数可用?
<p></p>
来看第二个问题，见到了两个核函数，标准正态分布pdf和
<p></p>
<span class="math display">\[
k(x)= \begin{cases}
\frac{3}{4}(1-x^2),\quad &amp;x\leq 1 \\
0,\quad &amp; \text{otherwise}
\end{cases}
\]</span>
<p></p>
他们的特点是在<span class="math inline">\(\mathbb{R}\)</span>上的积分都是1.
<p></p>
如果用 <span class="math inline">\(k'(x)=100*k(x)\)</span>
拟合出的pdf基本上是真实pdf的100倍
<p></p>
同学(易大师)给出了一个简单证明:
<figure>
<img src="../images/nonparametric/kernelfunction_1.jpg" alt="kf proof" />
<figcaption aria-hidden="true">kf proof</figcaption>
</figure>
<p></p>
但是如果从原理部分理解过来，并不能得知为什么这样的核函数能用。选取的核函数应该要和指示函数等价，也就是说对于一个<span class="math inline">\(x\)</span>，样本落在<span class="math inline">\(x\)</span>的<span class="math inline">\(h\)</span>邻域的比例要和这些样本的核函数的和相等。不过由于我们正在估计这个随机变量的pdf，样本的分布是不知道的，我觉得无法推出这个条件。
<p></p>
<a href="https://www.ssc.wisc.edu/~bhansen/718/NonParametrics1.pdf">Lecture
Notes on Nonparametrics</a> 找到了一个lecture
notes，里面详细介绍了核函数相关内容，section 2.2中提到2阶核函数都是从
<p></p>
<span class="math display">\[
k_s(u)=\frac{(2s+1)!!}{2^{s+1}s!}(1-u^2)^s\mathbb{I}(|u|\leq1)
\]</span>
<p></p>
得到的。
<h2 data-number="3" id="section"><span class="header-section-number">3</span> …?</h2>
<p></p>
想一想该如何解释为什么核函数可以这么取:
<p></p>
固定一个<span class="math inline">\(y\)</span>，按照待估计连续型随机变量的分布再生成<span class="math inline">\(n\)</span>个样本，这n个样本的核函数值的和应该恰好等于落在y的h邻域内的样本的数量。（为了方便，直接取h=1，并且假设n个样本都位于y的h邻域内）
<p></p>
<span class="math display">\[
\begin{aligned}
    &amp;\sum_{i=1}^n \int_{-1}^1 P(x_i\in[a+y,a+da+y])k(a) \\
    =&amp; \sum_{i=1}^n \int_{-1}^1f(y+a)k(a)\\
    =&amp; \sum_{i=1}^n \int_{-1}^1(\frac{1}{m}\sum_{j=1}^m
k(x_j-y-a))k(a)\\
\end{aligned}
\]</span>
<p></p>
算到这里我就不会算了，我觉得没什么办法能处理<span class="math inline">\(x_j\)</span>，应该是不会等于<span class="math inline">\(n\)</span>的。
观察这个式子，固定y不行，对所有y再积分也不行，y取所有样本也不行，感觉无法解释。
<p></p>
但是如果假设再生成的样本是均匀分布，那么一个样本的核函数值的期望就是<span class="math inline">\(\int_0^1 k(x) dx\)</span>
这就是核函数的积分，结果是1。n个样本的核函数值的和的期望就是n
<p></p>
至于为什么不假设样本是服从和要估计的随机变量分布相同而是用均匀分布，我觉得只是因为好算，而且当h取得较小的时候区别不是很大。
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>