<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Median of medians & `std::nth_element`</title>
    <link rel="stylesheet" href="../../css/fonts.css" />
    <link rel="stylesheet" href="../../css/default.css" />
    <link rel="stylesheet" href="../../css/pygentize.css" />
    <link rel="stylesheet" href="../../css/chao-theorems.css">
    <link rel="stylesheet" href="../../css/sidenotes.css">
    <script defer src="../../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontPath: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../../">Home</a>
                <div class="navright">
                    <a href="../../draft">Drafts</a>
                    <a href="../../about">About</a>
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Median of medians & `std::nth_element`</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on June  4, 2023
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../../tags/alg/index.html" rel="tag">alg</a>, <a title="All pages tagged 'C++'." href="../../tags/C%2B%2B/index.html" rel="tag">C++</a>
        
    </div>    
    <section>
        是一点 selection algorithm
<p></p>
支持随机查找的数组中找到第k大的元素是只需要线性时间. <a href="https://en.wikipedia.org/wiki/Median_of_medians" class="uri">https://en.wikipedia.org/wiki/Median_of_medians</a>
<p></p>
c++标准库里面也有类似的算法, <a href="https://en.cppreference.com/w/cpp/algorithm/nth_element"><code>std::nth_element</code></a>
<p></p>
但是他没有返回值, 而是把有random access iterator的容器的元素顺序改变了,
保证比第n个元素大的都在第n个元素前面,第n个元素就是第n小的元素.
听起来过程和 median of medians 差不多一样, 此时我还不知道intro
sort这种东西… 于是准备写一个比 nth_element 更快的模板, 有返回值,
不改原来的序列的元素.
<p></p>
然后…成功成为小丑, 维基百科的 median of medians 抄下来比标准库慢好多…
<p></p>
<a href="https://quick-bench.com/q/2wMZ6VJm_E6787SGdwsQh_mMUOU">quickbenchmark</a>
<p></p>
median of medians 是把元素五个一组(一个 5-tuple)找中位数,
然后找到中位数的中位数(pivot). 现在有一半的tuple的中位数小于pivot,
每个tuple都有五个元素, 其中两个小于这个tuple的中位数,
两个大于这个tuple的中位数. 这样我们就知道了,
在tuple的中位数小于pivot的这些tuple里面,
小于等于该tuple中位数的元素(每个tuple有三个这样的元素)都一定小于pivot.
也就是说如果我们把<span class="math inline">\(\lceil \frac{n}{5}
\rceil\)</span>个tuple都按照他们的中位数大小关系排好序的话,
排在pivot所在的tuple前面的这些tuple里面,有60%是一定比pivot小的,
他们一定是前半个序列的前60%的元素,
同理排在pivot所在tuple后面的所有tuple,
每个都有三个元素比pivot大,他们一定位于后半序列的最后60%,
我们每次至少可以扔掉<code>50%*60%=30%</code>的元素(这是最坏情况,
pivot所在tuple经过排序之后恰好在第一个或最后一个, 实际上我们不排序!)
注意到选择pivot仍然是一个select过程, 我们一样可以用这个median of
median来做, 非常巧妙
<p></p>
<span class="math display">\[
T(n)=T(n/5)+T(0.7n)+O(n)
\]</span>
<p></p>
然后再来看看introsort是怎么做的
<p></p>
这是<code>stl_algo.h</code>的实现
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> _RandomAccessIterator<span class="op">,</span> <span class="kw">typename</span> _Size<span class="op">,</span> <span class="kw">typename</span> _Compare<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    _GLIBCXX20_CONSTEXPR</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    __introselect<span class="op">(</span>_RandomAccessIterator __first<span class="op">,</span> _RandomAccessIterator __nth<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>		  _RandomAccessIterator __last<span class="op">,</span> _Size __depth_limit<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>		  _Compare __comp<span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> <span class="op">(</span>__last <span class="op">-</span> __first <span class="op">&gt;</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>	<span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>	  <span class="cf">if</span> <span class="op">(</span>__depth_limit <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>	    <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>	      <span class="bu">std::</span>__heap_select<span class="op">(</span>__first<span class="op">,</span> __nth <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> __last<span class="op">,</span> __comp<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>	      <span class="co">// Place the nth largest element in its final position.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>	      <span class="bu">std::</span>iter_swap<span class="op">(</span>__first<span class="op">,</span> __nth<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>	      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>	    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>	  <span class="op">--</span>__depth_limit<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>	  _RandomAccessIterator __cut <span class="op">=</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>	    <span class="bu">std::</span>__unguarded_partition_pivot<span class="op">(</span>__first<span class="op">,</span> __last<span class="op">,</span> __comp<span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>	  <span class="cf">if</span> <span class="op">(</span>__cut <span class="op">&lt;=</span> __nth<span class="op">)</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>	    __first <span class="op">=</span> __cut<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>	  <span class="cf">else</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>	    __last <span class="op">=</span> __cut<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>	<span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>__insertion_sort<span class="op">(</span>__first<span class="op">,</span> __last<span class="op">,</span> __comp<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p></p>
introsort基本上就是quicksort的pivot划分过程+heap sort+insertion sort
<p></p>
但是stl是没有用插入排序的, 而且很多地方在语言上做了优化.
基本上还是一样的.
<p></p>
首先在list比较大的时候递归调用introsort,
首先用<code>std::__unguarded_partition_pivot</code>找个pivot,
方法是直接取当前序列的正中间的元素作为pivot. 然后根据要找的
nth_element和pivot相比哪个大来修改下一步递归的区间.
<p></p>
在list比较小的时候就直接用heap select, 这个函数是这样的:
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// This is a helper function for the sort routines.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> _RandomAccessIterator<span class="op">,</span> <span class="kw">typename</span> _Compare<span class="op">&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    _GLIBCXX20_CONSTEXPR</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    __heap_select<span class="op">(</span>_RandomAccessIterator __first<span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>		  _RandomAccessIterator __middle<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>		  _RandomAccessIterator __last<span class="op">,</span> _Compare __comp<span class="op">)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>__make_heap<span class="op">(</span>__first<span class="op">,</span> __middle<span class="op">,</span> __comp<span class="op">);</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span>_RandomAccessIterator __i <span class="op">=</span> __middle<span class="op">;</span> __i <span class="op">&lt;</span> __last<span class="op">;</span> <span class="op">++</span>__i<span class="op">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span> <span class="op">(</span>__comp<span class="op">(</span>__i<span class="op">,</span> __first<span class="op">))</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>	  <span class="bu">std::</span>__pop_heap<span class="op">(</span>__first<span class="op">,</span> __middle<span class="op">,</span> __i<span class="op">,</span> __comp<span class="op">);</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p></p>
先建堆, 然后满足条件就<code>pop</code>
<p></p>
<code>make_heap</code>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> _RandomAccessIterator<span class="op">,</span> <span class="kw">typename</span> _Compare<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    _GLIBCXX20_CONSTEXPR</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    __make_heap<span class="op">(</span>_RandomAccessIterator __first<span class="op">,</span> _RandomAccessIterator __last<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>		_Compare<span class="op">&amp;</span> __comp<span class="op">)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">typedef</span> <span class="kw">typename</span> iterator_traits<span class="op">&lt;</span>_RandomAccessIterator<span class="op">&gt;::</span><span class="dt">value_type</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>	  _ValueType<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">typedef</span> <span class="kw">typename</span> iterator_traits<span class="op">&lt;</span>_RandomAccessIterator<span class="op">&gt;::</span><span class="dt">difference_type</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>	  _DistanceType<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>__last <span class="op">-</span> __first <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>	<span class="cf">return</span><span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> _DistanceType __len <span class="op">=</span> __last <span class="op">-</span> __first<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      _DistanceType __parent <span class="op">=</span> <span class="op">(</span>__len <span class="op">-</span> <span class="dv">2</span><span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>	<span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>	  _ValueType __value <span class="op">=</span> _GLIBCXX_MOVE<span class="op">(*(</span>__first <span class="op">+</span> __parent<span class="op">));</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>	  <span class="bu">std::</span>__adjust_heap<span class="op">(</span>__first<span class="op">,</span> __parent<span class="op">,</span> __len<span class="op">,</span> _GLIBCXX_MOVE<span class="op">(</span>__value<span class="op">),</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>			     __comp<span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>	  <span class="cf">if</span> <span class="op">(</span>__parent <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>	    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>	  __parent<span class="op">--;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>	<span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p></p>
<code>_GLIBCXX_MOVE std::move</code>, 所有的临时变量都用右值引用存起来,
少了很多复制操作
<p></p>
我好慢…
<figure>
<img src="../../images/medianofmedians/2wMZ6VJm_E6787SGdwsQh_mMUOU.png" alt="2wMZ6VJm_E6787SGdwsQh_mMUOU" />
<figcaption aria-hidden="true">2wMZ6VJm_E6787SGdwsQh_mMUOU</figcaption>
</figure>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>