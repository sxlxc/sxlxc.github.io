<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Finding the largest slope of segments connecting two sets of points on 2D plane</title>
    <link rel="preload" href="../fonts/FiraSans-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-Italic.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/IosevkaCustom-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <link rel="stylesheet" href="../css/sidenotes.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Finding the largest slope of segments connecting two sets of points on 2D plane</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on July 23, 2023
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../tags/alg.html" rel="tag">alg</a>, <a title="All pages tagged 'CG'." href="../tags/CG.html" rel="tag">CG</a>
        
    </div>    
    <section>
        <blockquote>
<p></p>
好长的标题啊
</blockquote>
<p></p>
二维平面上有一些点 <span class="math inline">\(E\)</span>, 分成两组
<span class="math inline">\(B\)</span> 和 <span class="math inline">\(E\backslash B\)</span>. <span class="math inline">\(\forall b\in B, \forall c\in E\backslash
B\)</span>, find the largest slope of the segment <span class="math inline">\(bc\)</span>.
<p></p>
这个问题是在解决 parametric matroid optimization 的时候遇到的,
但是用这种方法得到的东西甚至没有最显然的办法快.
<h3 data-number="1" id="parametric-matroid-optimization"><span class="header-section-number">1</span> parametric matroid
optimization</h3>
<p></p>
问题大概是这样
<p></p>
<span class="math display">\[
\begin{aligned}
\max_x \quad &amp; (v-\lambda c)\cdot x\\
s.t. \quad
x(S)&amp;\leq r(S)  &amp;\forall S\subseteq E\\
x(E)&amp;=p\\
x&amp;\geq 0
\end{aligned}
\]</span>
<p></p>
有一个matroid <span class="math inline">\(M\)</span>, ground set 是
<span class="math inline">\(E\)</span>, rank 是 <span class="math inline">\(p\)</span>, 每个element的权重是一个线性函数, 随着
<span class="math inline">\(\lambda\)</span> 变化, 我们想要找到随着
<span class="math inline">\(\lambda\)</span>
变化的这个线性规划的最优解的函数 <span class="math inline">\(\tau\)</span>.
<p></p>
首先这个 <span class="math inline">\(\tau\)</span> 一定是 piecewise
linear convex function.
这是因为所有的约束都是线性的(虽然可能数量是ground set大小的指数函数),
<span class="math inline">\(x\)</span> 的范围是一个凸多面体,
凸多面体顶点的 <span class="math inline">\(x\)</span> 全部拿出来,
我们会得到一个候选的直线的集合, 然后实际上我们在这些直线里面取max,
找的是平面上直线的<a href="https://en.wikipedia.org/wiki/Kinetic_convex_hull#:~:text=The%20upper%20envelope%20of%20a%20set%20of%20static%20lines%20can,the%20two%20resulting%20upper%20envelopes.">upper
envelope</a>, <span class="math inline">\(\tau\)</span> 一定是piecewise
linear convex function.
<p></p>
然后关于<span class="math inline">\(\tau\)</span>上面的 breakpoints
数量还有一个很好的性质. 数量是 <span class="math inline">\(\Theta(mp^{1/3})\)</span>, 这个是<a href="https://link.springer.com/article/10.1007/PL00009354">Improved
Bounds for Planar k -Sets and Related Problems</a> 文章里证明的. (<span class="math inline">\(m=\|E\|\)</span>)
<p></p>
然后问题是怎么找到<span class="math inline">\(\tau\)</span>.
<h4 data-number="1.1" id="uniform-matroid"><span class="header-section-number">1.1</span> uniform matroid</h4>
<p></p>
uniform matroid 就是所有大小小于等于 <span class="math inline">\(p\)</span> 的 <span class="math inline">\(E\)</span> 的子集都是独立的. uniform
matroid的特殊情况下, 这个问题就变成一个叫做 <a href="https://en.wikipedia.org/wiki/K-set_(geometry)">k-level</a>
的问题. 从上面的规划也能看出来, 相当于对于所有<span class="math inline">\(\lambda\)</span>我们都找纵坐标最大的 <span class="math inline">\(p\)</span> 条直线. 这个有超快的算法. <a href="https://web.archive.org/web/20101104182509/http://www.cs.uwaterloo.ca/~tmchan/lev2d_7_7_99.ps.gz">Chan,
T. M. (1999). “Remarks on k-level algorithms in the plane”. Archived
from the original on 2010-11-04.</a> 然后我写了文章里一个比较慢的用
kinetic heap 的版本 <a href="https://github.com/congyu711/k-level">github</a>
<h4 data-number="1.2" id="graphic-matroid"><span class="header-section-number">1.2</span> graphic matroid</h4>
<p></p>
graphic matroid 的 ground set 是一个无向图里面的边集, ground
set的任何子集,只要在图里不成环就是独立的. 他的基也就是任何生成树.
<p></p>
graphic matroid 情况下的<span class="math inline">\(\tau\)</span>
也有超快的算法. <a href="https://link.springer.com/article/10.1007/PL00009396">https://link.springer.com/article/10.1007/PL00009396</a>
<p></p>
关于这两种特殊的matroid情况下 <span class="math inline">\(\tau\)</span>
上面的 breakpoints 数量有这样一个表.
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th>“beakpoints”</th>
<th>lowerbound</th>
<th>upperbound</th>
<th>ref</th>
</tr>
</thead>
<tbody>
<tr>
<td>k-level</td>
<td><span class="math inline">\(\Omega(nc^{\sqrt{\log k}})\)</span> for
some constant c</td>
<td><span class="math inline">\(O(n k^{1/3})\)</span></td>
<td><a href="https://en.wikipedia.org/wiki/K-set_(geometry)">https://en.wikipedia.org/wiki/K-set_(geometry)</a></td>
</tr>
<tr>
<td>spanning tree</td>
<td><span class="math inline">\(\Omega(m\alpha(n))\)</span> graph with m
edges and n vertices</td>
<td>the same as general matroid</td>
<td><a href="https://link.springer.com/article/10.1007/PL00009396">https://link.springer.com/article/10.1007/PL00009396</a></td>
</tr>
<tr>
<td>general matroid(number of different minimum weight bases)</td>
<td><span class="math inline">\(\Omega(nr^{1/3})\)</span></td>
<td><span class="math inline">\(O(nr^{1/3})\)</span></td>
<td>lb: <a href="https://link.springer.com/article/10.1007/PL00009396">https://link.springer.com/article/10.1007/PL00009396</a>
ub: <a href="https://link.springer.com/article/10.1007/PL00009354">https://link.springer.com/article/10.1007/PL00009354</a></td>
</tr>
</tbody>
</table>
<p></p>
想要找到一个办法快速把一般的matroid的<span class="math inline">\(\tau\)</span>计算出来.
<h3 data-number="2" id="geometric-view"><span class="header-section-number">2</span> geometric view</h3>
<p></p>
我最开始想, 我可以想办法按照<span class="math inline">\(\lambda\)</span>递增的顺序把 <span class="math inline">\(\tau\)</span> 上面所有breakpoints都找到.
假设我们现在的 <span class="math inline">\(\lambda=\lambda_1\)</span>,
当前在<span class="math inline">\(\lambda_1\)</span>我们也知道选择的optimum
base是什么. 我们要找base里的直线和base外面的直线的大于<span class="math inline">\(\lambda_1\)</span>的最小交点坐标. 也就是
<p></p>
<span class="math display">\[
\begin{aligned}
\min \quad  (b-d)/(c-a)\\
s.t. \quad
\{y=a\lambda+b\}&amp;\in B  \\
\{y=c\lambda+d\}&amp;\in E\backslash B\\
(b-d)/(c-a)&amp;\geq \lambda_1
\end{aligned}
\]</span>
<p></p>
我们找到下一个 <span class="math inline">\(\lambda\)</span> 之后要看
matroid base 是否改变. 上面这个优化问题只是找到base 和
不是base的直线的下一个交点, 但是他们交换了未必optimum base就会变.
<p></p>
下面有两个问题: 1. 快速找到下一个 <span class="math inline">\(\lambda\)</span> 2. 我们找的 <span class="math inline">\(\lambda\)</span> 有多少个?
<p></p>
其实到这里已经该意识到这个思路可能有问题了.
<p></p>
但是我反而觉得我这个办法超过了上面 kinetic spanning tree(graphic
matroid)的文章…
<h3 data-number="3" id="find-the-next-breakpoint"><span class="header-section-number">3</span> find the next breakpoint</h3>
<p></p>
相当于在二维平面里有两组点, 找点之间连线斜率最接近<span class="math inline">\(\lambda\)</span>的点对.
<p></p>
通过改变<span class="math inline">\(b\)</span>可以把约束改成<span class="math inline">\((b_i-b_j)/(a_i-a_j)\leq 0\)</span>,
再把所有点先对<span class="math inline">\(y=0\)</span>做对称在对<span class="math inline">\(y=x\)</span> 做对称, 就变成了无约束的<span class="math inline">\(\max
(b'_i-b'_j)/(a'_i-a'_j)\)</span>
<p></p>
如果只有一组点, 求连线斜率最大可以<span class="math inline">\(O(n\log
n)\)</span>的时间内算出, 因为有一个性质,
斜率最大的线段一定是在按a的大小排序之后相邻的两个点取到,
但是如果是两组点就没有了这个性质…
<h4 data-number="3.1" id="trivial-version"><span class="header-section-number">3.1</span> trivial version</h4>
<p></p>
这是问组里打acm同学得知的. cdq分治. <span class="math inline">\(O(n\log^2 n)\)</span>.
<p></p>
我问了打acm的同学, 可以使用叫做<a href="https://oi-wiki.org/misc/cdq-divide/#%E8%A7%A3%E5%86%B3%E5%92%8C%E7%82%B9%E5%AF%B9%E6%9C%89%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98">cdq分治</a>的技巧.
<p></p>
把所有二维点（不管是哪一组）按照a的大小排序, 然后开始分治。
把所有点分成左右两部分数量相等的点，两个组分别记为A和B，左侧的属于A组的点记为<span class="math inline">\(A_l\)</span>, 右侧A组记为<span class="math inline">\(A_r\)</span>, B组也同样记为<span class="math inline">\(B_l,B_r\)</span>,
斜率最大的线段可能出现在3个地方：
<ol type="1">
<li><span class="math inline">\(A_l,B_l\)</span>之间的连线</li>
<li><span class="math inline">\(A_r,B_r\)</span>之间的连线</li>
<li><span class="math inline">\(A_l,B_r\)</span> or <span class="math inline">\(A_r,B_l\)</span> 之间的连线</li>
</ol>
<p></p>
前两种情况我们递归解决。第三种情况单独处理，发现<span class="math inline">\(A_l,B_r\)</span> 或者 <span class="math inline">\(A_r,B_l\)</span>对应的点集都完全被 <span class="math inline">\(x=mid\)</span>这个直线给分开了，<span class="math inline">\(A_l,B_r\)</span>之间的连线斜率最大的点一定只在<span class="math inline">\(A_l\)</span>的右半凸包和<span class="math inline">\(B_r\)</span>的左半凸包取,
因为点已经排过序了，求凸包<span class="math inline">\(O(n)\)</span>，
然后问题变成怎么求<span class="math inline">\(A_l\)</span>的右半凸包和<span class="math inline">\(B_r\)</span>的左半凸包上的点连线的最大斜率.
这个问题实际上又是在求<a href="https://en.wikipedia.org/wiki/Bitangent">bitangent</a>. 可以做到
<span class="math inline">\(O(\log m)\)</span>.
<p></p>
<span class="math inline">\(T(n)=2T(n/2)+O(n)=O(n\log n)\)</span>
<h4 data-number="3.2" id="complicated-version"><span class="header-section-number">3.2</span> complicated version…</h4>
<p></p>
观察上面cdq分治的过程, 发现我们总是在维护左半, 然而 <a href="https://www.sciencedirect.com/science/article/pii/002200008190012X"><em>M.
H. Overmars and J. Van Leeuwen, “Maintenance of configurations in the
plane,” Journal of Computer and System Sciences, vol. 23, no. 2,
pp. 166–204, Oct. 1981, doi: 10.1016/0022-0000(81)90012-X.</em></a> 当中
fully dynamic convex hull 的数据结构几乎是在做一样的事.
他的数据结构是一个平衡树套平衡树. 我们直接把他的数据结构拿过来,
把base中的点和不在base的点分开, 外层平衡树每个节点维护八个半凸包,
每次delete或者insert操作之后都要维护我们要求的slope,
就可以在和动态凸包完全相同的时间内找出我们想要的下一个交点. 也就是<span class="math inline">\(O(\log^2 m)\)</span>. (我觉得应该没问题…)
<p></p>
<a href="https://hackmd.io/@r1NLzG2QQuKF14FgHKxugg/SJgOi8CSh">2D fully
dynamic convex hull notes-hackmd.io</a>
<p></p>
然后我注意到 kinetic spanning tree 的文章每个breakpoint大概要花 <span class="math inline">\(O(n^{2/3}\log^{c}n)\)</span>,
那这个动态凸包的方法岂不是超快. 然而没有那么好的事…
<h3 data-number="4" id="number-of-breakpoints"><span class="header-section-number">4</span> number of “breakpoint”s</h3>
<p></p>
然而实际上我找的这个 “breakpoints” 的数量不是 <span class="math inline">\(O(k)=O(mp^{1/3})\)</span>, 而是 <span class="math inline">\(O(m^2)\)</span>. 上文说的<a href="https://link.springer.com/article/10.1007/PL00009354">Improved
Bounds for Planar k -Sets and Related Problems</a>文章里的证明用到叫做
Polygons in Arrangements 的问题(实际上是表格里general matroid
lowerbound那个文章先提出来的) 看起来和我找 breakpoint的过程非常相似.
我以为我的 “breakpoints” 的数量就是 <span class="math inline">\(O(k)\)</span>.
<p></p>
可以构造出一定会遇到 <span class="math inline">\(m^2/4\)</span> 个
“breakpoints” 的matroid和直线. 比如
<figure>
<img src="https://s2.loli.net/2023/07/14/fl4snAitbNhKOd9.jpg" alt="counterexample" />
<figcaption aria-hidden="true">counterexample</figcaption>
</figure>
<p></p>
水平的直线都是最开始的optimum base, 然而每一条斜线都是loop,
都不能存在于任何一个base中, 因此我们找了<span class="math inline">\(m^2/4\)</span>个交点, 而真正的breakpoint个数是0个.
<p></p>
然后我又意识到,
花了这么久找到的极其复杂的动态凸包做法竟然比最显然的做法还要慢.
动态凸包的办法(假设他完全正确)计算整个 <span class="math inline">\(\tau\)</span> 需要 <span class="math inline">\(O(m^2\log^2 m+ kT')\)</span>, <span class="math inline">\(T'\)</span> 是计算一次rank的时间;
而最显然的办法, 直接提前算出所有直线的交点然后排序, 竟然只需要 <span class="math inline">\(O(m^2\log m+ kT')\)</span>…
<p></p>
然而如果你需要一个数据结构来维护平面上两组点之间连线的最大斜率,
并且需要支持对两个点集的插入删除操作, 动态凸包的办法或许是最快的?
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>