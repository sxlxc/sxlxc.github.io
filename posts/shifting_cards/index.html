<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Shifting Cards</title>
    <link rel="stylesheet" href="../../css/fonts.css" />
    <link rel="stylesheet" href="../../css/default.css" />
    <link rel="stylesheet" href="../../css/pygentize.css" />
    <link rel="stylesheet" href="../../css/chao-theorems.css">
    <link rel="stylesheet" href="../../css/sidenotes.css">
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });
        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontPath: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../../">Home</a>
                <div class="navright">
                    <a href="../../draft">Drafts</a>
                    <a href="../../about">About</a>
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Shifting Cards</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on May  3, 2023
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'zzz'." href="../../tags/zzz/index.html" rel="tag">zzz</a>
        
    </div>    
    <section class="body">
        <a href="https://hackmd.io/@r1NLzG2QQuKF14FgHKxugg/r1kQ4V67n">hackmd.io</a>搬过来的
<h1 data-number="1" id="chapter28-shifting-cards"><span class="header-section-number">1</span> Chapter28 Shifting Cards</h1>
<p></p>
proofs from the book chap 28. 这一章讲的是各种洗牌算法, 很有意思.
用看起来比较简单的模型分析了听起来很难分析的东西.
<ul>
<li>洗的牌是什么? 52张扑克牌</li>
<li>要洗成什么样子? 希望洗好之后出现任何一种排列的概率都大概是<span class="math inline">\(1/52!\)</span></li>
</ul>
<h2 data-number="1.1" id="preliminary"><span class="header-section-number">1.1</span> Preliminary</h2>
<p></p>
需要知道 birthday paradox 和 一个叫做 coupon collector 的问题,
生日悖论很常见, coupon collector 是这样一个问题:
盒子里有n个编号不同的球, 我们每次取一个记下编号然后放回,
我们取到所有1到n的标号的球的时候停止, 拿球的次数的期望是多少?
<p></p>
如果已经拿到了k种球, 想再拿到一个以前没拿过的球还需要拿多少次呢?
<p></p>
<span class="math display">\[
\sum_{s\geq
1}  (\frac{k}{n})^{s-1}(1-\frac{k}{n})s=\frac{1}{1-\frac{k}{n}}
\]</span>
<p></p>
所以想拿到n个不同的球需要拿的次数的期望是
<p></p>
<span class="math display">\[
\sum_{k=0}^{n-1} \frac{1}{1-\frac{k}{n}}=nH_n\approx n\log n
\]</span>
<p></p>
还有一件事, 取超过期望的次数的概率大概是多少? 这个问题被定义成 取得次数
<span class="math inline">\(V_n\)</span> 大于 <span class="math inline">\(m=\lceil{n\log n+cn}\rceil\)</span> 的概率是多少?
<p></p>
<span class="math inline">\(A_i\)</span>
是前m次抓取编号为i这个球都没有被抓上来的事件
<p></p>
<span class="math display">\[
\text{Prob}[V_n \geq m]=\text{Prob} \big[ \bigcup_i A_i\big] \leq \sum_i
\text{Prob}[A_i]=n(1-/n)^m\leq e^{-c}
\]</span>
<p></p>
还有一件事, 需要搞清楚如何衡量随机. 洗牌之后可能出现<span class="math inline">\(n!\)</span>种排列, 所有排列的集合是<span class="math inline">\(\Pi\)</span>, 从而构成了一个分布, <span class="math inline">\(E(\pi)\)</span> 表示出现<span class="math inline">\(\pi\)</span>这个排列的概率是多少.
我们想知道的就是洗牌之后的这个分布和均匀分布有多相似.
用一个叫做variation distance的东西来衡量, 定义是 <span class="math inline">\(\|Q_1-Q_2\|=\frac{1}{2}\sum_{\pi\in
\Pi}\|Q_1(\pi)-Q_2(\pi)\|\)</span>, 令 <span class="math inline">\(S=\{\pi\in \Pi\mid Q_1(\pi)&gt;Q_2(\pi)
\}\)</span>, variation distance就可以写成 <span class="math inline">\(\|Q_1(S)-Q_2(S)\| \mid S\in \Pi\)</span>.
<!-- > https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence 为什么这里不用kl散度?
 -->
<p></p>
下面可以介绍第一种洗牌方法啦
<h2 data-number="1.2" id="top-in-at-random-shuffles"><span class="header-section-number">1.2</span> Top-in-at-random shuffles</h2>
<p></p>
怎么洗? 拿到牌堆顶部的牌, 等概率插入到其他n个位置
<p></p>
洗牌之前的的排列是<span class="math inline">\(\pi\)</span>,
概率分布就记为<span class="math inline">\(E\)</span>, <span class="math inline">\(E(\pi)=1\)</span>, 其他概率都是0. 由上面variation
distance的定义, <span class="math inline">\(\|E-U\|=1-\frac{1}{n!}\)</span>, U是<span class="math inline">\(n!\)</span>种排列的均匀分布.
<p></p>
一次 top-in-at-random 洗牌之后, 有n种可能的排列, 每一种的概率都是<span class="math inline">\(1/n\)</span>, 可以算出<span class="math inline">\(\|E'-U\|=1-\frac{1}{(n-1)!}\)</span>
<p></p>
书当中提到这种洗牌方法如果不断地进行下去, 与均匀分布相比的variation
distance会 goes to zero exponentially fast.
<h2 data-number="1.3" id="strong-uniform-stopping-rules"><span class="header-section-number">1.3</span> Strong uniform stopping
rules</h2>
<p></p>
通过上面的例子我们大概知道洗牌是一个什么样的过程. 首先有一个洗牌的方法,
这个方法涉及到”随机”的做改变牌的顺序的操作, 然后把洗牌的方法重复很多次.
我们想知道什么时候(重复多少次这个方法)牌才可以说是”洗好了”.
<p></p>
stopping rules 是什么意思? 指的就是停止洗牌的规则,
满足什么条件我们就停止重复洗牌.
<p></p>
<img src="https://i.imgur.com/57SI38i.png" />
<p></p>
书里给出了 Top-in-at-random shuffles 的一个 stopping rule.
当开始洗牌之前牌堆最下面的一张牌被重新插入到牌堆内的时候停止.
<p></p>
这很有意思, 假设洗牌之前整个牌组的顺序是1,…,n,
我们可以发现进行任意次数的 Top-in-at-random shuffle 之后,
位于n下面的牌的所有排列出现的概率是相等的, 可以简单的归纳出.
因此当所有牌都位于n下面的时候,我们再把n这张牌用Top-in-at-random
shuffle插入到牌堆, 牌堆的所有排列出现的概率都是<span class="math inline">\(1/n!\)</span>.
<p></p>
下面我们想知道stopping rule满足的时候大概使用了多少次Top-in-at-random
shuffle.
<p></p>
哦, 好巧, 如果把这个过程反过来, 也就是最开始n在排队顶部,
每次在牌堆里随机抽一张牌扔到牌堆顶, 这就是刚刚计算过的coupon collector
问题. 直接使用上面的结果, 我们就知道如果shuffle的次数大于 <span class="math inline">\(k=\lceil{n\log n+cn}\rceil\)</span> 的概率是小于
<span class="math inline">\(e^{-c}\)</span>的.
<p></p>
<img src="https://i.imgur.com/f4Q5E9V.png" />
<p></p>
注意证明当中的第三个等号, 这是由于满足了stopping rule之后得到的<span class="math inline">\(x_j\)</span>就一定是uniform distribution了.
<p></p>
用这个lemma我们能得到
<p></p>
Top-in-at-random shuffles 加入上面说的stopping rule之后跑<span class="math inline">\(k=\lceil{n\log n+cn}\rceil\)</span>轮,
对均匀分布的variation distance 小于<span class="math inline">\(e^{-c}\)</span>.
<h2 data-number="1.4" id="riffle-shuffles"><span class="header-section-number">1.4</span> Riffle shuffles</h2>
<p></p>
这就是赌场当中的洗牌方法, 大概是把初始的牌堆分成两份,放在左右手中,
然后每次可以选择把左手或者右手的牌堆最下面的一张放到新的牌堆顶部.
<p></p>
<img src="https://i.imgur.com/qlnB8wO.png" />
<p></p>
一次riffle shuffle可能会产生多少种不同的排列?
<p></p>
假设左手拿了t张, 右手就有n-t张, 下面把两个序列组合起来,
相当于在n个位置里面选出t个来, 然后把左手的序列按顺序插入,
右手的n-t张也按顺序放入剩下的n-t个位置, 所以一共<span class="math inline">\(\binom{n}{k}\)</span>. k可以取0到n,
这n+1个情况当中都有一个是和’原来的排列’是一样的, 因此一共有<span class="math inline">\(2^n-n\)</span>个排列.
(我建议读下去之前想一想为什么对于不同的k没有其他重复的排列)
<blockquote>
<p></p>
However, the following model, developed first by Edgar N. Gilbert and
Claude Shannon in 1955 (at the legendary Bell Labs “Mathematics of
Communication” department at the time), has several virtues:
<ul>
<li>it is elegant, simple, and seems natural,</li>
<li>it models quite well the way an amateur would perform riffle
shuffles,</li>
<li>and we have a chance to analyze it.</li>
</ul>
</blockquote>
<p></p>
下面要说的就是进行一次 riffle shuffle 之后得到的分布是什么样子的.
<p></p>
Gilbert 和 Shannon 假设, 第一步从牌堆当中拿出上面t张牌的时候,
概率是<span class="math inline">\(\frac{1}{2^n}\binom{n}{k}\)</span>.
这很听起来很合理. 拿到n/2 左右的数字的概率要大于拿很少或者很多牌的概率.
之后把t张牌放到右手, n-t张牌放到左手. 当右手有r张牌,左手有l张牌的时候,
我们按照概率<span class="math inline">\(l/(l+r)\)</span>和<span class="math inline">\(r/(l+r)\)</span>把左手和右手的最下面的一张牌放下.
这听起来也很合理…
<h4 data-number="1.4.0.1" id="进行一次riffle-shuffle之后得到原来的排列的概率是多少"><span class="header-section-number">1.4.0.1</span> 进行一次riffle
shuffle之后得到原来的排列的概率是多少?</h4>
<p></p>
对于固定的k, 我们需要让右手的t张牌都是后放下的.
<p></p>
<span class="math display">\[
P=\sum_{k=0}^n
\frac{1}{2^n}\binom{n}{k}\frac{k!}{(n-k)!}=\frac{n+1}{2^n}
\]</span>
<h4 data-number="1.4.0.2" id="进行一次riffle-shuffle之后得到其他某种排列的概率是多少"><span class="header-section-number">1.4.0.2</span> 进行一次riffle
shuffle之后得到其他某种排列的概率是多少?</h4>
<p></p>
还剩下<span class="math inline">\(2^n-n-1\)</span>个不同的排列.
按照上面的假设, 我们知道这些剩下的排列出现的概率是相等的.
因为每个位置取左手牌堆当中的牌还是右手牌堆当中的牌的概率相等,
所以在选定k的条件下进行 riffle shuffle 得到的排列对应的概率都是相等的.
<p></p>
他们都是<span class="math inline">\(\frac{1}{2^n}\)</span>
<h4 data-number="1.4.0.3" id="strong-uniform-stopping-rule"><span class="header-section-number">1.4.0.3</span> strong uniform stopping
rule</h4>
<p></p>
这个规则是, 每次洗牌的时候首先要把前面k张牌分到右手,
后面n-k张牌放到左手,
此时我们就在左右手的卡片上分别写下<code>0</code>和<code>1</code>,
不断重复 riffle shuffle
会让每个卡片上写下一个<code>0/1</code>构成的二进制串,
当所有卡片上的字符串都不同的时候我们停止重复 riffle shuffle.
<p></p>
我们考虑 riffle shuffle 的逆过程. 上面我们说过, 按照 Gilbert 和 Shannon
的假设, 给定k, 一个位置是放上左手的卡片还是放上右手的卡片的概率是相等的,
也就是说, 卡片上写下<code>0</code>或者<code>1</code>的概率是相等的.
通过上面的图我们观察到, 如果把k次riffle shuffle反过来做,
最后得到的初始牌堆的排列, 卡牌上面写的二进制串是有序的.
因此我们可以这样理解,
每一轮都给所有卡牌上的二进制串加一位,50%的概率是<code>0</code>,
50%的概率是<code>1</code>, 等到所有卡牌上的二进制串都不同的时候,
我们按照二进制串来给卡牌排序, 得到所有排列的概率都一样.
因为这个二进制串对于每个卡牌来说都是perfectly random and independent.
<h4 data-number="1.4.0.4" id="t"><span class="header-section-number">1.4.0.4</span> T</h4>
<p></p>
最后, 我们还想知道进行多少次 riffle shuffle 之后才满足了stopping rule.
也就是说多少次shuffle会让卡牌上的二进制串都不同?
<p></p>
终于用到了开头提到的生日悖论.
<p></p>
<span class="math display">\[
\text{Prob}[T&gt;k]=1-\prod_{i=1}^{n-1}(1-\frac{i}{2^k})
\]</span>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>