<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>DAG with smallest number of vertices</title>
    <link rel="preload" href="../fonts/FiraSans-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-Italic.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/IosevkaCustom-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <link rel="stylesheet" href="../css/sidenotes.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">DAG with smallest number of vertices</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on January 26, 2023
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../tags/alg.html" rel="tag">alg</a>, <a title="All pages tagged 'combinatorics'." href="../tags/combinatorics.html" rel="tag">combinatorics</a>
        
    </div>    
    <section>
        <!-- >我还没有非常仔细的想这个问题，也还没去查。这个问题可能非常简单，可能已经有人研究过这个问题了 -->
<p></p>
寒假听到一个问题，家族中有多少对父子多少对爷爷和孙子，问家族中人数最少有几人。
<p></p>
把这个问题变成，考虑一个DAG，给出DAG中长度（边的数量）为 <span class="math inline">\(l_i\)</span> 的路径的数量 <span class="math inline">\(a_i\)</span> ，求出顶点数量最少的满足条件的DAG
<h2 data-number="1" id="一个更简单的版本"><span class="header-section-number">1</span> 一个更简单的版本?</h2>
<p></p>
如果不是一般的 DAG ，而是一个 <a href="https://en.wikipedia.org/wiki/Arborescence_(graph_theory)">arborescence</a>
？
<p></p>
嗯… <span class="math inline">\(|V|=|E|+t\)</span>, <span class="math inline">\(t\)</span>是树的个数.
<ol type="1">
<li>长度越长的路径显然数量要少于长度短的路径数量</li>
<li>如果只有一个约束(长度为<span class="math inline">\(l\)</span>的路径数量是<span class="math inline">\(a\)</span>), 可以贪心解决</li>
</ol>
<h3 data-number="1.1" id="点数的upperbound"><span class="header-section-number">1.1</span> 2/6 点数的upperbound?</h3>
<p></p>
arborescence 情况下, 点数的上界是<span class="math inline">\(\sum
a_i(l_i+1)\)</span>.
<p></p>
(<span class="math inline">\(a_i(l_i+1)\)</span>的排序与<span class="math inline">\(l_i\)</span>的排序应该是没什么关系的)
<p></p>
也许能够证明最优解中点数的上界是 <span class="math inline">\(\max
\{a_i(l_i+1)\}\)</span> ?
<hr />
<p></p>
arborescence 可以看成 <a href="https://math.mit.edu/~goemans/18433S07/arborescence.pdf">intersection
of two matroids</a>
<p></p>
然而我们关于长度为<span class="math inline">\(L\)</span>的路径的数量的约束却并不是matroid.
ground set 是一个 arborescence 森林中的边, 如果长度为<span class="math inline">\(L\)</span>的路径数量小于等于<span class="math inline">\(A\)</span>, 选择的边集就是一个independent set.
这种描述不能满足 exchange property.
<p></p>
(本来还想通过说明即使只有一个路径数量约束也是 intersection of three
matroids
来证明即使是arborescence这个问题也是NP-Hard…不过就算成立也不能这样说明.)
<hr />
<h3 data-number="1.2" id="也许-greedy-可行"><span class="header-section-number">1.2</span> 也许 greedy 可行</h3>
<p></p>
把约束按照<span class="math inline">\(L_i\)</span>从大到小排序,
对于一个长度是<span class="math inline">\(L_i\)</span>的路径数量是<span class="math inline">\(a_i\)</span>条这样的约束, 构造这样一个有向树:
<pre><code>O -&gt; O -&gt; ... -&gt; O -&gt; O
      \-&gt; O       \-&gt; O
       |-&gt; O       |-&gt; O
      ...         ...</code></pre>
<p></p>
在<span class="math inline">\(L_i\)</span>对应的深度的顶点插入合适数量的儿子.
<p></p>
然后根据构造出的有向树中长度为更小的 <span class="math inline">\(L_j\)</span> 的路径的数量并修改 <span class="math inline">\(a_j\)</span>.
<p></p>
换一种描述方法: 假设根的深度是0. 用一个pair<span class="math inline">\((L_i,
A_i)\)</span>来表示一个路径数量的约束(长度为<span class="math inline">\(L_i\)</span>的路径有<span class="math inline">\(A_i\)</span>条), 把这些pair按照 <span class="math inline">\(L_i\)</span> 的降序排序.
最优解的树形图形状像上面画的一样, 深度为<span class="math inline">\(L_1\)</span>, 所有深度为<span class="math inline">\(p\)</span>的顶点都是同一个深度为<span class="math inline">\(p-1\)</span>的顶点的子节点. 深度为<span class="math inline">\(L_1\)</span>的节点有<span class="math inline">\(A_1\)</span>个, 深度为<span class="math inline">\(L_i(i\geq 2)\)</span> 的顶点有 <span class="math inline">\(A_i-A_{i-1}+L_i-L_{i-1}+1\)</span> 个.
<!-- ...想想怎么证明或者找反例 -->
<p></p>
<strong>只有一个路径数量约束(长度为<span class="math inline">\(L\)</span>的路径数量是<span class="math inline">\(A\)</span>), <span class="math inline">\(|V|=L+A\)</span></strong>
<p></p>
观察到对于<span class="math inline">\(k\)</span>个路径约束,
使用的点数总共是
<p></p>
<span class="math display">\[
\begin{align*}
|V|&amp;=L_1+A_1+\sum_{i=2}^N A_i-A_{i-1}+L_i-L_{i-1}\\
&amp;= A_N+L_N
\end{align*}
\]</span>
<p></p>
也可以验证这样的构造恰好满足长度为<span class="math inline">\(L_i\)</span>的路径有<span class="math inline">\(A_i\)</span>条.
<h2 data-number="2" id="dag"><span class="header-section-number">2</span> DAG</h2>
<p></p>
不允许重边存在.
<p></p>
arborescence 情况下的贪心不再成立了, 比如这样的图: <img src="../images/minDAG/L2A4V4.jpg" alt="L2A4V4" />
<p></p>
有向树的情况下是4个点是形成不了4条长度为2的路径的.
<h3 data-number="2.1" id="n-个点的dag形成的长度为-l-的路径数量"><span class="header-section-number">2.1</span> <span class="math inline">\(n\)</span> 个点的DAG形成的长度为 <span class="math inline">\(L\)</span> 的路径数量?</h3>
<p></p>
就是一个把能连接的边全部连接上的DAG吧。
<p></p>
路径数量就是组合数, <span class="math inline">\(f(n,L)\)</span> 表示
<span class="math inline">\(n\)</span> 个点的DAG形成的长度为 <span class="math inline">\(L\)</span> 的路径数量,
看起来可能要找递推关系用生成函数算了, 但是实际上 <span class="math inline">\(f(n,L)\)</span> 相当于 在 <span class="math inline">\([n]\)</span> 当中包含 <span class="math inline">\(L\)</span> 个元素的子集的个数, 给这个DAG拓扑排序,
所有可能的路径都是序列 <span class="math inline">\(\{1,2,...,n\}\)</span> 的所有子序列,
数量也就是包含 <span class="math inline">\(L\)</span> 个元素的子集个数.
<a href="https://www2.math.upenn.edu/~wilf/gfology2.pdf">generatingfunctionology</a>
1.5 是用生成函数算组合数的例子.
<p></p>
然后考虑一下连接了所有 <span class="math inline">\(n(n-1)/2\)</span>
条边的DAG如果要保证长度为L的路径数量最多(仍然是 <span class="math inline">\(\binom{n}{L+1}\)</span> ), 最多可以删除多少条边?
<p></p>
对于 <span class="math inline">\(n=4\)</span> 的DAG和 <span class="math inline">\(L=2\)</span> , 我们最多可以删掉一个边 <span class="math inline">\((1,4)\)</span>, 就是上面的图; 对于 <span class="math inline">\(L=3\)</span> 就可以只保留 <span class="math inline">\((1,2), (2,3), (3,4)\)</span> 了; <span class="math inline">\(L=1\)</span> 一条边都不能删除.
<p></p>
可以删掉的边数只与 <span class="math inline">\(L\)</span> 有关, 是 <span class="math inline">\(L(L-1)/2\)</span> (<span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 不能相邻的条件是 <span class="math inline">\(n-(j-i+1)\leq L-2\)</span>)
<p></p>
目前还没有想到接下来该怎么办…
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>