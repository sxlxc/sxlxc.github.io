<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Matroid base packing and covering</title>
    <link rel="preload" href="../fonts/FiraSans-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-Italic.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/IosevkaCustom-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <link rel="stylesheet" href="../css/sidenotes.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
        <!-- A table of contents on the left side, but only for screens
                that are big enough -->
        <div id="contents-big">
            <p class="mini-header">Contents <a id="up-arrow" href="#">↑</a></p>
            <ul>
<li><a href="#base-packing-base-covering">Base packing &amp; base covering</a></li>
<li><a href="#matroid-strength-and-density">Matroid strength and density</a>
<ul>
<li><a href="#integral-gap">Integral gap</a></li>
<li><a href="#duality">Duality</a></li>
</ul></li>
<li><a href="#computing-the-strength-and-density">Computing the strength and density</a></li>
</ul>
        </div>
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Matroid base packing and covering</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on January  4, 2025
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'matroid'." href="../tags/matroid.html" rel="tag">matroid</a>, <a title="All pages tagged 'optimization'." href="../tags/optimization.html" rel="tag">optimization</a>, <a title="All pages tagged 'combinatorics'." href="../tags/combinatorics.html" rel="tag">combinatorics</a>
        
    </div>    
    <section>
        <p></p>
There are few text books in combinatorial optimization discussing topics
in matroid base packing, while matroid base covering(<a href="https://en.wikipedia.org/wiki/Matroid_partitioning">matroid
partition problem</a>) is everywhere. Packing and covering of trees in
graphs is discussed in chapter 51 of <span class="citation" data-cites="Schrijver2004">[<a href="#ref-Schrijver2004" role="doc-biblioref">1</a>]</span>.
<h1 data-number="1" id="base-packing-base-covering"><span class="header-section-number">1</span> Base packing &amp; base
covering</h1>
<div class="theorem-environment Problem" data-index="1" type="Problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p></p>
Given a matroid <span class="math inline">\(M=(E,\mathop{\mathrm{\mathcal I}})\)</span> and
its bases <span class="math inline">\(\mathop{\mathrm{\mathcal
B}}\)</span>, find
<ol type="1">
<li>(minimum base covering) the min number of bases whose union is <span class="math inline">\(E\)</span>, and</li>
<li>(maximum base packing) the max number of pairwise disjoint
bases.</li>
</ol>
</div>
<p></p>
These problems can be formulated with the following integer programs,
base packing: <span class="math display">\[\begin{align*}
\max&amp;   &amp;   \sum_{B\in\mathop{\mathrm{\mathcal B}}}
x_B&amp;            &amp;   &amp;\\
s.t.&amp;   &amp;   \sum_{B:e\in B} x_B &amp;\leq
1   &amp;   &amp;\forall e\in E\\
    &amp;   &amp;              x_B&amp;\in
\set{0,1}  &amp;   &amp;\forall \text{ base $B$}
\end{align*}\]</span>
<p></p>
base covering: <span class="math display">\[\begin{align*}
\min&amp;   &amp; \sum_{B\in\mathop{\mathrm{\mathcal B}}}
x_B&amp;            &amp;   &amp;\\
s.t.&amp;   &amp; \sum_{B:e\in B} x_B &amp;\geq 1   &amp;   &amp;\forall
e\in E\\
    &amp;   &amp;            x_B&amp;\in \set{0,1}  &amp;   &amp;\forall
\text{ base $B$}
\end{align*}\]</span>
<p></p>
Integer programs are hard and these IPs have exponential number of
variables. We consider the linear relaxations.
<blockquote>
<p></p>
For any LP with bounded solutions, there must exist an optimal solution
with support at most For similar problem on integer programming, one
might think that there is also a small support based on the knowledge
that the optimal solution for the integer program is simply a integer
point inside the feasible region. However, the size of support for
integer programs is not that small. Currently the best known upperbound
is roughly <span class="math inline">\(m\cdot
\mathop{\mathrm{polylog}}(\|{A}\|_1)\)</span>, see <a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol283-isaac2023/LIPIcs.ISAAC.2023.13/LIPIcs.ISAAC.2023.13.pdf">this
paper</a>.
</blockquote>
<p></p>
Actually these two problems are not hard on general matroids. Both of
them can be solved in polynomial number of independence oracle calls.
<ul>
<li>matroid base covering = matroid partitioning ≈ matroid union. Let
<span class="math inline">\(M=(E,\mathop{\mathrm{\mathcal I}})\)</span>
be the matroid. The minimum number of bases that cover the groundset is
<span class="math inline">\(\arg\min\limits_k r_{k}(E)=|E|\)</span>,
where <span class="math inline">\(r_{k}(\cdot)\)</span> is the rank
function of <span class="math inline">\(M^k\)</span>.</li>
<li>matroid base packing ≈ matroid union. Maximum integral base packing
number is <span class="math inline">\(\arg\max\limits_k
r_{k}(E)=kr(M)\)</span>.</li>
</ul>
<p></p>
Thus the integral version of these two problem is polynomial solvable
(in terms of the number of oracle calls) since matroid union is
tractable. We will discuss computing the fractional version later.
<blockquote>
<p></p>
The base covering number may be much larger than the base packing
number, since <span class="math inline">\(E-B_k\)</span> may not be
independent for <span class="math inline">\(M\)</span>. (<span class="math inline">\(B_k\)</span> is the union of bases in the optimal
packing)
</blockquote>
<h1 data-number="2" id="matroid-strength-and-density"><span class="header-section-number">2</span> Matroid strength and density</h1>
<p></p>
We will talk about matroid strength and density and their relation with
base packing and covering in this section. I think none of the results
is new. You can find some of them in <span class="citation" data-cites="catlin_fractional_1992">[<a href="#ref-catlin_fractional_1992" role="doc-biblioref">2</a>]</span>
and <span class="citation" data-cites="fan_extensions_2019">[<a href="#ref-fan_extensions_2019" role="doc-biblioref">3</a>]</span>.
<p></p>
The fractional base covering number for graphic matroids are called
fractional arboricity. It is known that the fractional arboricity <span class="math inline">\(\alpha(G)\)</span> equals to <span class="math inline">\(\max\limits_{\emptyset \subsetneq X\subset
E}\frac{|X|}{r(X)}\)</span>. Define the density for a matroid <span class="math inline">\(M\)</span> as <span class="math inline">\(\alpha(M)=\max\limits_{\emptyset \subsetneq
X\subset E}\frac{|X|}{r(X)}\)</span>. The name “density” comes from
<span class="citation" data-cites="catlin_fractional_1992">[<a href="#ref-catlin_fractional_1992" role="doc-biblioref">2</a>]</span>. I
use symbol <span class="math inline">\(\alpha\)</span> since density is
a generalization of arboricity.
<p></p>
For the packing part consider the fractional version of Nash-Williams
theorem,
<div class="theorem-environment Theorem" data-index="2" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p></p>
The fractional spanning tree packing number of a connected graph <span class="math inline">\(G=(V,E)\)</span> equals to <span class="math inline">\(\max \frac{|E[\mathcal P]|}{|\mathcal
P|-1}\)</span>, where the maximum is taken among all partitions <span class="math inline">\(\mathcal P\)</span> of <span class="math inline">\(V\)</span>.
</div>
<p></p>
The fraction in above theorem can be rewrite as <span class="math inline">\(\frac{|E-F|}{r(E)-r(F)}\)</span>, which only uses
elements in the groundset and the rank function and thus can be
generalized to non-graphic matroids. The maximum of this fraction, <span class="math inline">\(\sigma(M)=\max_{F\subset
E}\frac{|E-F|}{r(E)-r(F)}\)</span> is called matroid strength.(The name
also comes from <span class="citation" data-cites="catlin_fractional_1992">[<a href="#ref-catlin_fractional_1992" role="doc-biblioref">2</a>]</span>.)
<p></p>
For the connections between density and strength, we have the following
inequality,
<p></p>
<span class="math display">\[
\alpha(M)=\max \frac{|X|}{r(X)} \geq \frac{|E|}{r(E)} \geq \min
\frac{|E-F|}{r(E)-r(F)} =\sigma(M).
\]</span>
<div class="theorem-environment Theorem" data-index="3" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">3</span></span>
<p></p>
Maximum fractional base packing number is <span class="math inline">\(\sigma(M)\)</span>.
</div>
<div class="theorem-environment Proof" type="Proof">
<span class="theorem-header"><span class="type">Proof</span></span>
<p></p>
The proof is similar to the graph strength proof for tree packing in
<span class="citation" data-cites="Schrijver2004">[<a href="#ref-Schrijver2004" role="doc-biblioref">1</a>]</span>. Let <span class="math inline">\(B(M)\)</span> be the base polytope of <span class="math inline">\(M\)</span> and <span class="math inline">\(\Pi\)</span> be the powerset of <span class="math inline">\(E\)</span>. Consider the following linear
programs, <span class="math display">\[\begin{align*}
LP1=\min&amp;   &amp;    lx&amp;  \\
    s.t.&amp;   &amp;    x&amp;\in B(M)
\end{align*}\]</span>
<p></p>
<span class="math display">\[\begin{align*}
LP2=\max&amp;   &amp; \sum_{F\subsetneq E} y_{E\setminus
F}(r(E)-r(F))&amp;  \\
    s.t.&amp;   &amp; \sum_{F\subsetneq E} y_{E\setminus F}
\chi^{E\setminus F} &amp; \leq l\\
        &amp;   &amp;    y &amp; \in \R^\Pi_+
\end{align*}\]</span>
<p></p>
and the dual of <span class="math inline">\(LP2\)</span>, <span class="math display">\[\begin{align*}
    LP3=\min&amp;   &amp;    lx&amp;                                    &amp;   &amp;\\
        s.t.&amp;   &amp;    x^T\chi^{E\setminus F} &amp;\geq r(E)-r(F)
&amp;   &amp;\forall F\subsetneq E\\
            &amp;   &amp;           x&amp;\in
\R^E_+                    &amp;   &amp;
\end{align*}\]</span>
<p></p>
We first prove that the polyhedron in <span class="math inline">\(LP3\)</span>, <span class="math inline">\(Q=\{ x |
x\geq 0,x^T\chi^{E\setminus F} \geq r(E)-r(F) \quad \forall F\subsetneq
E\}\)</span> is the base polytope of <span class="math inline">\(M\)</span>. One can see that <span class="math inline">\(B(M)\subseteq Q\)</span>. Now suppose <span class="math inline">\(Q\)</span> is larger than <span class="math inline">\(B(M)\)</span>, there must exists <span class="math inline">\(x\in Q\)</span> such that <span class="math inline">\(x(U)&gt;r(U)\)</span> for some <span class="math inline">\(U\subseteq E\)</span>. Thus <span class="math inline">\(\mathop{\mathrm{OPT}}(LP3)&gt;\mathop{\mathrm{OPT}}(LP1)\)</span>.
However, for the optimal solution <span class="math inline">\(x\)</span>
to <span class="math inline">\(LP1\)</span> and any feasible solution
<span class="math inline">\(y\)</span> to <span class="math inline">\(LP2\)</span> we have <span class="math display">\[
  \mathop{\mathrm{OPT}}(LP1)\geq \sum_{F\subsetneq E} y_{E\setminus
F}\chi^{E\setminus F}\cdot x = \sum_{F\subsetneq E} y_{E\setminus F}
\left(\sum_{e\in E}x_e-\sum_{e\in F}x_e\right)\geq \sum_{F\subsetneq E}
y_{E\setminus F} \left(r(E)-r(F)\right)=\mathop{\mathrm{OPT}}(LP3)
\]</span> Hence <span class="math inline">\(Q=B(M)\)</span>.
<p></p>
Recall that <span class="math inline">\(\sigma(M)=\min_{F\subsetneq
E}\frac{|E\setminus F|}{r(E)-r(F)}\)</span>. Note that <span class="math inline">\(\sigma(M)\geq 1\)</span>. <span class="math inline">\(\sigma(M)\)</span> can be interpreted as the
largest <span class="math inline">\(\lambda&gt;1\)</span> such that
<span class="math inline">\(|E\setminus F| \geq
\lambda(r(E)-r(F))\)</span> holds for all <span class="math inline">\(F\subsetneq E\)</span>. Hence <span class="math inline">\(\sigma(M)=\max \{\lambda | \mathbf 1\in \lambda
B(M)\}\)</span> since <span class="math inline">\(Q=B(M)\)</span>. For
fixed <span class="math inline">\(\lambda\)</span>, <span class="math inline">\(\mathbf 1 \in \lambda B(M)\)</span> if and only if
there exists <span class="math inline">\(\lambda_b\geq 0\)</span> for
all bases of <span class="math inline">\(M\)</span> such that <span class="math inline">\(\sum_b \lambda_b=\lambda\)</span> and <span class="math inline">\(\sum_b \lambda_b \chi^b\leq 1\)</span>. Hence this
shows <span class="math inline">\(\sigma(M)\)</span> is exactly the base
packing LP <span class="math inline">\(\max\{\sum_b{\lambda_b}|
\sum_{b}\lambda_b\chi^b\leq 1,\lambda_b\geq 0\;\forall b\in
B\}\)</span>.
</div>
<blockquote>
<p></p>
Note that this proof is a straightforward generalization of the tree
packing theorem in <span class="citation" data-cites="Schrijver2004">[<a href="#ref-Schrijver2004" role="doc-biblioref">1</a>]</span>, which is
similar to the blocking polyhedra method described in <span class="citation" data-cites="schrijver_polyhedral_1986">[<a href="#ref-schrijver_polyhedral_1986" role="doc-biblioref">4</a>]</span>.
</blockquote>
<hr />
<p></p>
In <span class="citation" data-cites="Galtier_2018b">[<a href="#ref-Galtier_2018b" role="doc-biblioref">5</a>]</span> there is a
constructive proof that recovers the optimal <span class="math inline">\(F\subset E\)</span> in <span class="math inline">\(\sigma(M)\)</span> from any optimal solution of
hitting set LP(dual to base packing).
<p></p>
The idea is to show that any fraction solution <span class="math inline">\(y\)</span> to base hitting set can be converted to
another solution <span class="math inline">\(y'\)</span> such that
<span class="math inline">\(y'(e)\in \set{0,c}\)</span> for some
global constant <span class="math inline">\(c\)</span> and <span class="math inline">\(\sum_e w(e)y'(e)\leq \sum_e w(e)y(e)\)</span>.
<p></p>
Define two sets <span class="math inline">\(P, P'\in
\R^{|E|}\)</span>, <span class="math display">\[\begin{equation*}
\begin{aligned}
P   &amp;=\set{y\in \R^{|E|}: y(e)\geq 0 \;\forall e\in E; y(B)\geq 1 \;
\forall \text{ base B}},\\
P'     &amp;=\set{y\in P: \forall e\in E, \exists B^e\in \mathcal B
\; s.t. \; e\in B^e \land y(B^e)=\min_{B\in \mathcal B} y(B)}.
\end{aligned}
\end{equation*}\]</span>
<p></p>
<span class="math inline">\(P'\)</span> is contained in <span class="math inline">\(P\)</span> and every element is in a minimum base
with respect to weights <span class="math inline">\(y:E\to \R\)</span>.
<div id="y2yprime" class="theorem-environment Proposition" data-index="4" type="Proposition">
<span class="theorem-header"><span class="type">Proposition</span><span class="index">4</span></span>
<p></p>
Let <span class="math inline">\(y\in P\)</span>. There exists <span class="math inline">\(y'\in P'\)</span> s.t. <span class="math inline">\(y(e)\geq y'(e)\)</span> for all <span class="math inline">\(e\)</span>.
</div>
<div class="theorem-environment Proof" type="Proof">
<span class="theorem-header"><span class="type">Proof</span></span>
<p></p>
The proof is contrustive. Let <span class="math inline">\(B=\set{e_1,\ldots, e_r}\)</span> be a minimum
weight base with <span class="math inline">\(y\)</span>. Assume that
<span class="math inline">\(y(e_1)\leq \ldots \leq y(e_r)\)</span>. For
each element <span class="math inline">\(e\notin B\)</span>, let <span class="math inline">\(C_e\)</span> be the fundamental circuit in <span class="math inline">\(B+e\)</span>. Then we define <span class="math inline">\(y'\)</span> as follows. <span class="math display">\[\begin{equation*}
y'(e)=
\begin{cases}
y(e)    &amp; e\in B\\
\min\limits_{e\in C_e} y(e) &amp;e\notin B
\end{cases}
\end{equation*}\]</span>
<p></p>
One can easily verify that <span class="math inline">\(y'(e)\leq
y(e)\)</span> for all <span class="math inline">\(e\)</span> and <span class="math inline">\(B\)</span> is still the minimum weight base under
weights <span class="math inline">\(y'\)</span>. Now it remains to
show that <span class="math inline">\(y'\in P'\)</span>.
<ol type="1">
<li>Every element is in a minimum base. For <span class="math inline">\(e\in B\)</span> this is automatically satisfied.
We consider <span class="math inline">\(e\notin B\)</span>. Let <span class="math inline">\(f\in C_e\)</span> be the element in the
fundamental circuit of <span class="math inline">\(B+e\)</span> with
smallest weight <span class="math inline">\(y(e)\)</span>. <span class="math inline">\(B^e=B+e-f\)</span> is a base and we have <span class="math inline">\(y'(B^e)=y'(B)\)</span>.</li>
<li>For all base <span class="math inline">\(B'\)</span>, <span class="math inline">\(y'(B')\geq 1\)</span> holds since <span class="math inline">\(y'(B')\geq y'(B) = y(B)\geq
1\)</span>.</li>
</ol>
</div>
<!-- The importance of $P'$ is that for any $y\in P'$ and set $E(\theta,y)=\set{e\in E:y(e)\leq \theta}$, 
the size of the intersection of $E(\theta,y)$ and any minimum weight base $B$ is exactly the rank of $E(\theta,y)$. The proof is by contradiction. -->
<p></p>
<a href="#y2yprime" title="Proposition 4">Proposition 4</a> shows that
we can easily convert any solution to base hitting set (<span class="math inline">\(y\in P\)</span>) to a more well-behaved solution
(<span class="math inline">\(y'\in P'\)</span>). Note that our
final goal is to find some special optimal solution <span class="math inline">\(y'\in \{0,c\}^E\)</span>. Thus we want to
analyse the optimal <span class="math inline">\(y'\)</span> further.
<p></p>
We are solving <span class="math inline">\(\max_{y'} \set{\sum_e
w(e)y'(e)| y'\in P'}\)</span>. Notice that the minimum
weight base under weight <span class="math inline">\(y'\)</span>
should always have weight 1. We want to prove that for any weight <span class="math inline">\(w\)</span> there is an optimal <span class="math inline">\(y'\)</span> with only one non-zero value. Thus
we consider expressing the solution with values in <span class="math inline">\(y'\)</span>. Suppose we have computed the
optimal <span class="math inline">\(y'\)</span> and let <span class="math inline">\(\theta_1 &lt; \ldots &lt; \theta_h\)</span> be the
set of distinct values in <span class="math inline">\(y'\)</span>.
Let <span class="math inline">\(\mu_i\)</span> be the number of edges
with <span class="math inline">\(y'(e)=\theta_i\)</span>. One
immediate observation is that the objective <span class="math inline">\(\sum_e w(e)y'(e)\)</span> can be written as
<span class="math inline">\(\sum_i \theta_i \mu_i\)</span>. Let <span class="math inline">\(v_i=r(\set{e: y'(e)\leq \theta_{i}})-r(\set{e:
y'(e)\leq \theta_{i-1}})\)</span> be the rank increment when
involving elements with <span class="math inline">\(y'(e)=\theta_i\)</span>. Another immediate
observation is that the weight of minimum base is <span class="math inline">\(\sum_{e\in B} y'(e)=\sum_i
v_i\theta_i=1\)</span>. Based on these observations we write the
following LP for <span class="math inline">\(\theta\)</span>.
<p></p>
<span class="math display">\[\begin{equation*}
\begin{aligned}
\min&amp;   &amp;   &amp;\sum_i \mu_i\theta_i \\
s.t.&amp;   &amp;   &amp;\sum_i v_i\theta_i = 1\\
    &amp;   &amp;   &amp;0 \leq \theta_1\leq \theta_2\leq \ldots \leq
\theta_h
\end{aligned}
\end{equation*}\]</span>
<p></p>
Suppose the optimal <span class="math inline">\(y'\)</span> is
given, we can compute the optimal <span class="math inline">\(\theta\)</span> in the above LP and recover
another solution <span class="math inline">\(y''\)</span> to
base hitting set. One can see that <span class="math inline">\(y''\)</span> is still in <span class="math inline">\(P'\)</span>. This LP has <span class="math inline">\(h+1\)</span> linearly independent constraints and
<span class="math inline">\(h\)</span> variables. Thus only <span class="math inline">\(h\)</span> of the constraints are tight. We have
already known that <span class="math inline">\(\sum_i v_i\theta_i =
1\)</span> must be tight. Then there is always an optimal solution <span class="math inline">\(\theta\)</span> such that <span class="math inline">\(0=\theta_1=\ldots=\theta_k &lt;
\theta_{k+1}=\ldots = \theta_h =c\)</span>. Let <span class="math inline">\(F\)</span> be the set of elements with <span class="math inline">\(y''(e)=0\)</span>. Note that the minimum
weight base contains <span class="math inline">\(r(F)\)</span> elements
of <span class="math inline">\(F\)</span>. Thus we known that <span class="math inline">\(c=\frac{1}{r(E)-r(F)}\)</span>. The objective is
<span class="math inline">\(\sum_{e\in E} w(e)y''(e)=\sum_{e\in
E-F}w(e)y''(e)=\frac{\sum_{e\in E-F} w(e)}{r(E)-r(F)}\)</span>.
<hr />
<div class="theorem-environment Theorem" data-index="5" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">5</span></span>
<p></p>
Minimum fractional base covering is <span class="math inline">\(\alpha(M)\)</span>.
</div>
<p></p>
The proof is similar to and easier than the previous one. The
corresponding polyhedron in <span class="math inline">\(LP3\)</span>
becomes <span class="math inline">\(\{x| x^T\chi^{F}\leq r(F)\; \forall
F\subset E\}\)</span> which is exactly the independence polytope.
Similarly, constructive proof for base covering exists <span class="citation" data-cites="Galtier_2018b">[<a href="#ref-Galtier_2018b" role="doc-biblioref">5</a>]</span>.
<p></p>
Note that these two theorems can be generalized to weighted packing and
covering of matroid bases.
<h2 data-number="2.1" id="integral-gap"><span class="header-section-number">2.1</span> Integral gap</h2>
<p></p>
It is known that the integral base packing number is <span class="math inline">\(\floor{\sigma(M)}\)</span> and the integral base
covering number is <span class="math inline">\(\ceil{\alpha(M)}\)</span>. Thus the integral gap
for both base packing and covering are quite small.
<p></p>
In <span class="citation" data-cites="fan_extensions_2019">[<a href="#ref-fan_extensions_2019" role="doc-biblioref">3</a>]</span> there
are stronger theorems describing the relations between integral
packing/covering number and <span class="math inline">\(\sigma\)</span>
or <span class="math inline">\(\alpha\)</span>.
<div class="theorem-environment Theorem" data-index="6" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">6</span></span>
<p></p>
Let <span class="math inline">\(\varepsilon\in [0,1)\)</span> be the
fractional part of <span class="math inline">\(\sigma(M)\)</span> or
<span class="math inline">\(\alpha(M)\)</span>, then there exists a
packing(covering) of size <span class="math inline">\(\floor{\sigma(M)}\)</span>(<span class="math inline">\(\ceil{\alpha(M)}\)</span>), one of the independnet
sets in the packing(covering) is of size at most <span class="math inline">\(\varepsilon\cdot r(M)\)</span>.
</div>
<h2 data-number="2.2" id="duality"><span class="header-section-number">2.2</span> Duality</h2>
<p></p>
Applying the rank function of matroid dual derives the following
(Theorem 1 in <span class="citation" data-cites="catlin_fractional_1992">[<a href="#ref-catlin_fractional_1992" role="doc-biblioref">2</a>]</span>),
<div class="theorem-environment Theorem" data-index="7" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">7</span></span>
<p></p>
For matroid <span class="math inline">\(M\)</span> without any loop or
coloop, <span class="math display">\[\sigma(M^*)=\frac{\alpha(M)}{\alpha(M)-1}\]</span>
</div>
<p></p>
Another relation worth noting is hitting set and set covering. The
hitting set problem for matroid bases is known as computing the cogirth
of the matroid. However, base covering is not a dual problem for
cogirth. Sets in the corresponding hitting set problem of set covering
is <span class="math inline">\(S_e=\set{B|e\in B}\)</span> for all <span class="math inline">\(e\in E\)</span>.
<h1 data-number="3" id="computing-the-strength-and-density"><span class="header-section-number">3</span> Computing the strength and
density</h1>
<p></p>
For graphic matroids, the strength and fractional arboricity are known
to be computable in strongly polynomial time. See chapter 51.4 in <span class="citation" data-cites="Schrijver2004">[<a href="#ref-Schrijver2004" role="doc-biblioref">1</a>]</span> and <a href="https://courses.grainger.illinois.edu/cs598csc/fa2024/Notes/lec-tree-packing.pdf">this
notes</a>.
<p></p>
The idea is to consider the dual problem which has only <span class="math inline">\(|E|\)</span> variables. If there is a separation
oracle for testing whether a dual solution <span class="math inline">\(x\)</span> is feasible, then ellipsoid method can
be used for a polynomial time algorithm.
<p></p>
For spanning tree packing the dual is graph min-cut problem, which is
easy for graphic matroids but NP-Hard for general matroids (to find the
cogirth). The separation oracle = find minimum weight base. Chekuri and
Quanrud <span class="citation" data-cites="chekuri_near_linear_2017">[<a href="#ref-chekuri_near_linear_2017" role="doc-biblioref">6</a>]</span>
discovered near-linear time approximation scheme for some implicit
fraction packing problems. For fractional base packing, their algorithm
outputs a <span class="math inline">\((1-\epsilon)\)</span>-approximation with <span class="math inline">\(\tilde O(n/\epsilon^2)\)</span> independence
oracle calls. For the capacitated version, the number of oracle calls
becomes <span class="math inline">\(\tilde O(rn/\epsilon^2)\)</span>.
<blockquote>
<p></p>
Almost at the same time, <a href="https://dblp.org/pid/54/3460.html">Jérôme Galtier</a> published
similar results for graphs <span class="citation" data-cites="Galtier_2018a">[<a href="#ref-Galtier_2018a" role="doc-biblioref">7</a>]</span> and for matroids <span class="citation" data-cites="Galtier_2018b">[<a href="#ref-Galtier_2018b" role="doc-biblioref">5</a>]</span>.
</blockquote>
<p></p>
For spanning tree covering the dual is finding a maximum edge set whose
intersection with each spanning tree is at most 1. This problem can be
thought as a set cover, in which the sets are <span class="math inline">\(\set{T|e\in T}\)</span> for each edge <span class="math inline">\(e\)</span>. The separation oracle solves the
following problem: given edge weight <span class="math inline">\(x:E\to
[0,1]\)</span>, is there a spanning tree with weight greater than 1? We
can simply find a matroid base with the largest weight. Thus for general
matroid we can find the fractional arboricity through ellipsoid method.
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-Schrijver2004" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">A.
Schrijver, <a href="http://books.google.com/books?hl=en&amp;lr=&amp;id=mqGeSQ6dJycC&amp;oi=fnd&amp;pg=PA1&amp;dq=Combinatorial+optimization+Polyhedra+and+Efficiency&amp;ots=xPOTKYfsKd&amp;sig=aH7tG7iKLIIljl5SMMx2yWNMAbM">Combinatorial
optimization <span>Polyhedra</span> and <span>Efficiency</span></a>,
Springer, 2004.</div>
</div>
<div id="ref-catlin_fractional_1992" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">P.A. Catlin, J.W. Grossman, A.M. Hobbs, H.-J.
Lai, Fractional arboricity, strength, and principal partitions in graphs
and matroids, <em>Discrete Applied Mathematics</em>. 40 (1992) 285–302
<a href="https://doi.org/10.1016/0166-218X(92)90002-R">10.1016/0166-218X(92)90002-R</a>.</div>
</div>
<div id="ref-fan_extensions_2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">G.
Fan, H. Jiang, P. Li, D.B. West, D. Yang, X. Zhu, Extensions of matroid
covering and packing, <em>European Journal of Combinatorics</em>. 76
(2019) 117–122 <a href="https://doi.org/10.1016/j.ejc.2018.09.010">10.1016/j.ejc.2018.09.010</a>.</div>
</div>
<div id="ref-schrijver_polyhedral_1986" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">A.
Schrijver, Polyhedral proof methods in combinatorial optimization,
<em>Discrete Applied Mathematics</em>. 14 (1986) 111–133 <a href="https://doi.org/10.1016/0166-218X(86)90056-9">10.1016/0166-218X(86)90056-9</a>.</div>
</div>
<div id="ref-Galtier_2018b" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">J.
Galtier, Fast approximation of matroid packing and covering, <em>Annals
of Operations Research</em>. 271 (2018) 575–598 <a href="https://doi.org/10.1007/s10479-018-2756-8">10.1007/s10479-018-2756-8</a>.</div>
</div>
<div id="ref-chekuri_near_linear_2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">C.
Chekuri, K. Quanrud, Near-<span>Linear</span> <span>Time</span>
<span>Approximation</span> <span>Schemes</span> for some
<span>Implicit</span> <span>Fractional</span> <span>Packing</span>
<span>Problems</span>, in: <em>Proceedings of the
<span>Twenty</span>-<span>Eighth</span> <span>Annual</span>
<span>ACM</span>-<span>SIAM</span> <span>Symposium</span> on
<span>Discrete</span> <span>Algorithms</span></em>, <span>Society for
Industrial and Applied Mathematics</span>, 2017: pp. 801–820 <a href="https://doi.org/10.1137/1.9781611974782.51">10.1137/1.9781611974782.51</a>.</div>
</div>
<div id="ref-Galtier_2018a" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">J.
Galtier, Computing weighted strength and applications to partitioning,
<em>SIAM Journal on Discrete Mathematics</em>. 32 (2018) 2747–2782 <a href="https://doi.org/10.1137/15M102914X">10.1137/15M102914X</a>.</div>
</div>
</div>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>