<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Linear time linebreaker?</title>
    <link rel="stylesheet" href="../../css/fonts.css" />
    <link rel="stylesheet" href="../../css/default.css" />
    <link rel="stylesheet" href="../../css/pygentize.css" />
    <link rel="stylesheet" href="../../css/chao-theorems.css">
    <link rel="stylesheet" href="../../css/sidenotes.css">
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });
        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontPath: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../../">Home</a>
                <div class="navright">
                    <a href="../../draft">Drafts</a>
                    <a href="../../about">About</a>
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Linear time linebreaker?</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on October 28, 2025
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../../tags/alg/index.html" rel="tag">alg</a>, <a title="All pages tagged 'typography'." href="../../tags/typography/index.html" rel="tag">typography</a>
        
    </div>    
    <section class="body">
        Recently, Typst has merged a <a href="https://github.com/typst/typst/pull/6161">PR</a> which includes
support for <a href="https://typst.app/blog/2025/typst-0.14#character-level-justification">character-level
justification</a>. This feature is an extension to the linebreak
algorithm. It allows changes in the inter-character space in each word
and this adjustment may affect line break decisions. For line breaking
Typst uses <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Plass_line-breaking_algorithm">Knuth–Plass
line-breaking algorithm</a><!--
--><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><div class="sidenote">See this nice <a href="https://laurmaedje.github.io/posts/layout-models/">blog post</a>
for a comparison between the layout models of TeX and Typst.</div><!--
-->.
<p></p>
Let’s forget about typography and focus on the algorithmic part of
line-breaking problems.
<h1 data-number="1" id="line-breaking"><span class="header-section-number">1</span> line-breaking</h1>
<div class="theorem-environment Problem" data-index="1" type="Problem" title="line breaking">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span><span class="name">line breaking</span></span>
<p></p>
Given a sequence <span class="math inline">\(S\)</span> and a cost
function <span class="math inline">\(c\)</span> mapping from contiguous
subsequences (substrings) of <span class="math inline">\(S\)</span> to
<span class="math inline">\(\R\)</span>, divide the sequence <span class="math inline">\(S\)</span> (the paragraph) into substrings <span class="math inline">\(S_1,\dots,S_k\)</span> (lines) such that <span class="math inline">\(\sum_{i\in [k]} c(S_i)\)</span> is minimized.
</div>
<p></p>
We over-simplify things here. In real typography world the cost function
not only depends on the line <span class="math inline">\(S_i\)</span>
but also other things like the length of the line.
<p></p>
The input size <span class="math inline">\(n\)</span> is the number of
elements in <span class="math inline">\(S\)</span> and for now the cost
function <span class="math inline">\(c\)</span> is assumed to be given
in an oracle.
<p></p>
This line breaking admits a <span class="math inline">\(O(n^2)\)</span>
dynamic programming algorithm:
<p></p>
<span class="math display">\[
    f(i)=\max_{0\leq j&lt;i} f(j)+c(S[j..i])
\]</span>
<h1 data-number="2" id="smawk-algorithm"><span class="header-section-number">2</span> SMAWK algorithm</h1>
<p></p>
<a href="https://en.wikipedia.org/wiki/Knuth-Plass_line-breaking_algorithm#Computational_complexity">Wikipedia</a>
says that this problem can be solve in linear time using SMAWK
algorithm, which finds the minimum in each row of a <span class="math inline">\(n\times m\)</span> totally monotone matrix in
<span class="math inline">\(O(n+m)\)</span> <!--
--><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><div class="sidenote">This is a footnote. See section 6.5 in <a href="https://courses.grainger.illinois.edu/cs473/sp2016/notes/06-sparsedynprog.pdf">Jeff
Erickson’s lecture notes</a>).</div><!--
-->.
<p></p>
The matrix here would be <span class="math inline">\(M[i,j]=f(j)+c(S[j..i])\)</span>. The dynamic
programming algorithm is in fact finding the minimum for each row. If we
can show this matrix <span class="math inline">\(M\)</span> is totally
monotone, then we can make optimal line breaking decisions in linear
time. A matrix is totally monotone, if each row’s minimum value occurs
in a column which is equal to or greater than the column of the previous
row’s minimum. A special case of totally monotone is <a href="https://en.wikipedia.org/wiki/Monge_array">Monge array</a> which
requires <span class="math inline">\(M[i,k]+M[j,\ell]\geq
M[j,k]+M[i,\ell]\)</span> for all <span class="math inline">\(i&lt;j\)</span> and <span class="math inline">\(k&lt;\ell\)</span>. Now we focus on checking Monge
property of <span class="math inline">\(M\)</span>.
<p></p>
Doing some easy math, one can see that the Monge property depends on the
following inequality on the cost function <span class="math inline">\(c\)</span>: <span class="math display">\[
c(S[i..k])+c(S[j..\ell])\leq c(S[i..\ell])+c(S[j..k]))\quad \forall
i&lt;j&lt;k&lt;\ell
\]</span>
<p></p>
This looks like some intersecting supermodular property on set
functions, but our domain here is the collection of substrings.
<p></p>
As cited on wiki, <a href="https://doi.org/10.1016/0196-6774(88)90032-6">this paper</a>
stated that the problem of optimally breaking up text of a paragraph
into lines can be done in linear time. The cost function is <span class="math inline">\(c(X)=(len(X)-parwidth)^2\)</span>, where <span class="math inline">\(len(X)\)</span> is the sum of character width in
<span class="math inline">\(X\)</span> and <span class="math inline">\(parwidth\)</span> is the width of the paragraph.
This cost function does generate a Monge array, but this is not the cost
in the <a href="https://gwern.net/doc/design/typography/tex/1981-knuth.pdf">original
paper</a> of Knuth and Plass.
<p></p>
They introduced several cost functions: “first-fit”, “best-fit” and
“demerits”, with increasing complexity. For simplicity of analysis, we
consider the “best-fit” case, where the cost function is the sum of
badness and penalty.
<p></p>
Penalty relates to the ending character of each line. For example, we
want as few number of hyphens as possible, then the penalty for ending
hyphen should be large. Badness meansures how much do we need to
stretch/shrink the white spaces in a line to make it fit. More formally,
badness is <span class="math inline">\(c\left(\frac{L}{W}\right)^3\)</span> where <span class="math inline">\(L\)</span> is the sum of default length of all
characters in this line, <span class="math inline">\(W\)</span> is the
total length of stretchable/shrinkable whitespaces and <span class="math inline">\(c\)</span> is some universal constant factor.
<p></p>
Note that penalties do not affect Monge property, since the number of
occurence of ending characters (<span class="math inline">\(S[k]\)</span> and <span class="math inline">\(S[\ell]\)</span>) in the same on LHS and RHS.
However, for badness, one can verify that <span class="math inline">\(M\)</span> is not always a Monge array. I think
total monotonicity is violated too but don’t have a counterexample now…
<h1 data-number="3" id="character-level-operations"><span class="header-section-number">3</span> character-level operations</h1>
<p></p>
Assume the cost function is still a parabola on line width and we
further add some character-level operations.
<ol type="1">
<li>We can break all ligatures in one line. The cost function becomes
<span class="math inline">\(c(X)=\min\{c_1(X),c_2(X)\}\)</span>.</li>
<li>Stretch/shrink font glyphs and adjust kerning. <span class="math inline">\(c(X)=\min_{\theta}(\theta {\rm len}_1(X)+{\rm
len}_2(X)-parlength)^2\)</span>, where <span class="math inline">\({\rm
len}_{1,2}\)</span> are the total length of whitespaces and other
characters in <span class="math inline">\(X\)</span> and <span class="math inline">\(\theta\in [lb,ub]\)</span> is the stretching
factor.</li>
</ol>
<p></p>
Unfortuantely, neither of the operations preserves Monge property and i
believe they break total monotonicity as well.
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>