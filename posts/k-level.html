<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>k-level</title>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <link rel="stylesheet" href="../css/sidenotes.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontPath: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                    poly: "\\mathop{\\operatorname{poly}}",
                    polylog: "\\mathop{\\operatorname{polylog}}",
                    span: "\\mathop{\\operatorname{span}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">k-level</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on September 25, 2022
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../tags/alg.html" rel="tag">alg</a>, <a title="All pages tagged 'CG'." href="../tags/CG.html" rel="tag">CG</a>
        
    </div>    
    <section>
        <a href="https://en.wikipedia.org/wiki/K-set_(geometry)">K-set</a>
<h2 data-number="0.1" id="duality-between-point-and-line"><span class="header-section-number">0.1</span> duality between point and
line</h2>
<p></p>
二维平面上有一条直线<span class="math inline">\(y=ax-b\)</span>和一个点<span class="math inline">\((c,d)\)</span>，现在我想描述一下点和直线之间的相对位置；
点如果在直线上面，说明<span class="math inline">\(x=c\)</span>的时候直线取得的<span class="math inline">\(y\)</span>小于<span class="math inline">\(d\)</span>,也就是说<span class="math inline">\(d&gt;ac-b\)</span>，这里也可以将 <span class="math inline">\(c,d\)</span>看成系数，<span class="math inline">\(a,b\)</span>当成带入的坐标，表示的意思变成<span class="math inline">\((a,b)\)</span>这个点位于直线<span class="math inline">\(y=cx-d\)</span>的上面
<h2 data-number="0.2" id="upper-envelope-of-linear-functions"><span class="header-section-number">0.2</span> upper envelope of linear
functions</h2>
<p></p>
现在二维平面上有很多条直线，我想找到最上面的边缘线(upper envelope)
<figure>
<img src="../images/k-level/fig1.svg" alt="fig1" />
<figcaption aria-hidden="true">fig1</figcaption>
</figure>
<p></p>
假设在横坐标为<span class="math inline">\(x'\)</span>处直线<span class="math inline">\(y=ax-b\)</span>位于 upper envelope 上，这个点<span class="math inline">\((x',y')\)</span>位于所有其他直线上方，
那么根据对偶，这些直线对偶对应的点也都位于点<span class="math inline">\((x',y')\)</span>对应的直线的上方，而实际上这条直线就是凸包的下边缘，
因为它一定过某个直线对偶对应的点。
<h2 data-number="0.3" id="k-level"><span class="header-section-number">0.3</span> k-level</h2>
<p></p>
k-level 是推广的upper
envelope，找的是最上面的k条直线(实际上定义是下方正好有k条直线的那个边缘线)，
也就是需要找到正好上方有k-1条直线的那个边缘线。这个边缘线上的点上方应该有恰好k-1条直线，
下方有n-k条直线。类似upper envelope
的处理，研究和直线互为对偶的点。要找的是一个类似凸包下边缘的东西
上的点，这些点对应的直线就是能够出现在k-level 边缘线上的那些直线。
<p></p>
下面是 <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.9042&amp;rep=rep1&amp;type=pdf">1999
Timothy M. Chan</a> 中的算法
<p></p>
首先容易的方法是枚举所有直线的交点<span class="math inline">\(O(n^2)\)</span>，然后对这些交点分出的所有区间计算最大的k个直线（应该是<span class="math inline">\(O(n^3)\)</span>， <span class="math inline">\(n^2\)</span>个区间，每个区间用median of
medians线性时间找到top k）
<p></p>
<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.9042&amp;rep=rep1&amp;type=pdf">1999
Timothy M. Chan</a>
的思路是从左到右扫描x轴，维护两个优先队列，一个维护在当前的x
rank小于k的直线是哪些，一个维护大于等于k的是哪些。如果把
横轴x看成时间，优先队列在维护一些会在一维直线上做匀速运动的点，这种东西叫做
<a href="https://en.wikipedia.org/wiki/Kinetic_data_structure">kinetic
data structure</a>，实现方法先不讨论
<p></p>
有了这种数据结构之后就可以按照这样的步骤维护 k-level:
<figure>
<img src="../images/k-level/fig2.jpg" alt="maintain the polygon chain" />
<figcaption aria-hidden="true">maintain the polygon chain</figcaption>
</figure>
<p></p>
可以看出来k-level的复杂度就相当于m次插入、大小为n的这种优先队列维护起来的复杂度
## detail
<h3 data-number="0.3.1" id="目前-kinetic-priority-queue-的复杂度"><span class="header-section-number">0.3.1</span> 目前 kinetic priority queue
的复杂度</h3>
<p></p>
kinetic priority queue 需要实现的操作： - 插入点 - 删除点 -
advance（把时间往后推） - 维护最小值
<p></p>
文中讨论复杂度基于两个上界：优先队列中点的数量的上界<span class="math inline">\(n\)</span>，插入操作的数量上界<span class="math inline">\(m\)</span>
<div class="theorem-environment Observation" data-index="1" type="Observation" title="2.1">
<span class="theorem-header"><span class="type">Observation</span><span class="index">1</span><span class="name">2.1</span></span>
<p></p>
For elements moving linearly, the number of times S.min changes is <span class="math inline">\(O(m\alpha(n))\)</span>.
</div>
<p></p>
实际上kinetic priority queue在维护的是一个子集的lower envelope，lower
envelope上的breakpoint数量有 上限<span class="math inline">\(O(m\alpha(m))\)</span>（来源见<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=1%200.1.1.44.9042&amp;rep=rep1&amp;type=pdf">1999
Timothy M. Chan</a>）(这个奇怪复杂度是怎么来的？<a href="https://zh.wikipedia.org/wiki/%20%E9%81%94%E6%96%87%E6%B3%A2%E7%89%B9-%E6%AC%A3%E7%AD%96%E7%88%BE%E5%BA%8F%E5%88%97">zh.wikipedia</a>,
<a href="https://en.wikipedia.org/wiki/Davenport%E2%80%93Schinzel_sequence">en.wikipedia</a>
lower envelope 上的线段编号写成一个序列就 是这个Davenport–Schinzel
sequence)
<p></p>
<strong>实际上这个界对于直线是非常不紧的，线段才可能产生长度为4的交替子序列，直线只能产生长度为2的；所以线段是3阶DS
sequence而 直线是1阶，从对偶对应的凸包也可以看出breakpoint上限是<span class="math inline">\(O(n)\)</span>，所以文章这里考虑的是带上插入删除操作的</strong>
<!-- *先考虑直接做这些操作的复杂度，我感觉插入删除操作比较少，推时间比较多。求lower envelope相当于凸包$O(n\log n)$，插入
删除主要影响advance操作，我觉得需要维护每个直线下一次出现交点是什么时候，这个东西可以用$O(n^2)$时间预处理；
或者说把整个kpq当成一个有序数组，按照在当前时间（横坐标）下的值（纵坐标）排序，advance只会交换其中
两个元素的位置，插入删除会影响插入位置和相邻位置的交点时间，这样貌似插入删除$O(n)$其他操作$O(1)$?* -->
<p></p>
使用暴力方法，复杂度<span class="math inline">\(T(n,m)=O(mn\alpha(n))\)</span>
<p></p>
复杂度这里实际上算的是从一个空的KPQ开始，插入点，删除点，advance，按照需要进行操作，直到<span class="math inline">\(t=\inf\)</span>花费的时间；
Observation给出了advance操作的数量上限，每次advance必然发生<span class="math inline">\(S.min\)</span>改变。插入和删除操作数量上界是<span class="math inline">\(m\)</span>。
<p></p>
文章中用分治，把每个kinetic priority queue <span class="math inline">\(S\)</span>维护的集合分成<span class="math inline">\(r\)</span>组，每组用一个kinetic priority
queue维护(<span class="math inline">\(P\in S.\Pi\)</span>)，
然后再用一个额外的kinetic priority queue <span class="math inline">\(S.Q\)</span>维护这r个子队列最小值的最小值
<p></p>
KPQ <span class="math inline">\(S\)</span>
只需要暴露出上面说的四种操作，首先<span class="math inline">\(S.maintain(),S.advance()\)</span>如下，很好理解
<figure>
<img src="../images/k-level/fig3.jpg" alt="maintain &amp; advance" />
<figcaption aria-hidden="true">maintain &amp; advance</figcaption>
</figure>
<p></p>
<span class="math inline">\(S.insert(),S.delete()\)</span>:
<figure>
<img src="../images/k-level/fig4.jpg" alt="insert &amp; delete" />
<figcaption aria-hidden="true">insert &amp; delete</figcaption>
</figure>
<p></p>
insert 把要插入的元素放在大小最小的那个子队列<span class="math inline">\(P\)</span>中，然后更新<span class="math inline">\(S.Q\)</span>中的那个<span class="math inline">\(P.min()\)</span>，最后维护<span class="math inline">\(S\)</span>
<p></p>
delete 完全类似
<h4 data-number="0.3.1.1" id="nnm"><span class="header-section-number">0.3.1.1</span> <span class="math inline">\(N(n,m)\)</span></h4>
<p></p>
<span class="math inline">\(N(n,m)\)</span>表示递归方法中一个KPQ做advance操作的数量
<p></p>
<span class="math display">\[N(n,m)=\sum_{i=1}^r  N(n/r,m_i)+O(m\alpha(n))\]</span>
<p></p>
其中<span class="math inline">\(\sum
m_i=m\)</span>（所有插入次数被分配到了每个子队列中）
<p></p>
<span class="math display">\[N(n,m)=O(\alpha(n) m\log_r n)\]</span>
<blockquote>
<table>
<thead>
<tr>
<th>层数</th>
<th>个数</th>
<th>sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td><span class="math inline">\(m\alpha(n)\)</span></td>
</tr>
<tr>
<td>2</td>
<td>r</td>
<td><span class="math inline">\(m\alpha(\frac{n}{r})\)</span></td>
</tr>
<tr>
<td>3</td>
<td><span class="math inline">\(r^2\)</span>(r个一组，一共r组)</td>
<td><span class="math inline">\(m\alpha(\frac{n}{r^2})\)</span></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td><span class="math inline">\(\log_r n\)</span></td>
<td><span class="math inline">\(n/r\)</span></td>
<td><span class="math inline">\(m\alpha(1)\)</span></td>
</tr>
</tbody>
</table>
<p></p>
最后得到<span class="math inline">\(\sum_{i=1}^{\log_r n}
\alpha(\frac{n}{r^{i-1}})*m\)</span>
<p></p>
sum里面直接取最大值，可以得到上面的结果
</blockquote>
<p></p>
复杂度：
<p></p>
<span class="math display">\[T(n,m)=\sum_{i=1}^r  T(n/r,m_i)+O(m\alpha(n)\log
n+mr\alpha(n))\]</span>
<p></p>
RHS第二项需要解释，<span class="math inline">\(O(m\alpha(n)\log
n+mr\alpha(n))\)</span>完全是上面<span class="math inline">\(S\)</span>和<span class="math inline">\(S.Q\)</span>维护产生的复杂度， 现在文章认为<span class="math inline">\(S.Q\)</span>使用暴力方法，插入删除操作复杂度都是<span class="math inline">\(O(S.Q.size)\)</span>，<span class="math inline">\(S.advance()\)</span>A5说明每次<span class="math inline">\(S\)</span>的最小值改变 <span class="math inline">\(S.Q\)</span>都会进行一次插入和一次删除，所以<span class="math inline">\(S.advance()\)</span>就会让<span class="math inline">\(S.Q\)</span>产生<span class="math inline">\(O(m\alpha(n))\)</span>次插入和删除，每次<span class="math inline">\(O(r)\)</span>， 这部分复杂度就是<span class="math inline">\(mr\alpha(n)\)</span>（因为n小于m，队列中的元素数量肯定小于插入次数，<span class="math inline">\(S.insert()\)</span>执行次数一定少于 <span class="math inline">\(O(m\alpha(n))\)</span>，这里不用继续考虑D5和I5操作了）；其次是A1和M2中找<span class="math inline">\(P.next\)</span>最小的P，单独用一个大小为r的堆来
维护这个信息，回答A1和M2是常数时间，但是每次任意一个<span class="math inline">\(P.min\)</span>发生改变或者发生插入删除的时候都要<span class="math inline">\(\log r\)</span>时间维护， 需要<span class="math inline">\(O(N(n,m)\log r)=O(m\alpha(n)\log
n)\)</span>，令<span class="math inline">\(r=\lceil \log
n\rceil\)</span>
<p></p>
<span class="math display">\[T(n,m)=O(m\alpha(n)\log^2 n/\log \log
n)\]</span>
<p></p>
这种递归方法我写了代码<a href="https://github.com/congyu711/k-level">github</a>
<p></p>
感觉写的有点丑陋，而且用的是boost的heap
<h3 data-number="0.3.2" id="优化"><span class="header-section-number">0.3.2</span> 优化</h3>
<blockquote>
<p></p>
需要用到 semi dynamic convex hull （只支持删除操作的动态凸包），
去查了一下发现很多有趣的结果， - <a href="https://www.cs.princeton.edu/~chazelle/temp/451/451-2019/KirkSeidel.pdf">Kirkpatrick
and Seidel</a>把二维平面凸包做到<span class="math inline">\(O(n\log
k)\)</span> n是输入大小，k是输出大小。 -
完全动态的凸包（支持插入和删除）<a href="https://www.sciencedirect.com/science/article/pii/002200008190012X">Overmars</a>
做到了<span class="math inline">\(O(\log^2 n)\)</span> - semi dynamic
convex hull 仅插入单次操作可以做到单次<span class="math inline">\(O(\log
n)\)</span>，仅删除可以做到单次均摊<span class="math inline">\(O(\log
n)\)</span>
</blockquote>
<p></p>
先不讨论semi dynamic convex
hull的实现，如果已经有了一个维护删除操作下的凸包的数据结构，如何实现一个仅支持删除操作的KPQ？
<p></p>
首先如果是仅删除的KPQ，寻找最小值实际上就是在一些都从左端点在x=0、右端点位置不同的线段组成的
lower envelope， 同样根据上面的 DS sequence ，
可以看出两个线段组成最长交替子序列长度是3，是一个2阶DS
sequence，得知<span class="math inline">\(advance()\)</span>
次数上界也是<span class="math inline">\(O(n)\)</span>
<p></p>
那么我们可以先算出最开始的 lower envelope（一个凸包，<span class="math inline">\(O(n\log n)\)</span>）然后再用semi dynamic convex
hull去维护 删除操作，n个删除操作只需要<span class="math inline">\(O(n\log n)\)</span>
于是借用上面定义的衡量KPQ的复杂度<span class="math inline">\(T(n)=O(n\log n)\)</span>
<p></p>
这种方法先不写了，我认为我能把它成功写出的概率不大，而且过于复杂。首先上面说的
semi dynamic convex hull 只能做到只处理插入操作和只处理删除操作， 得到的
kinetic priority queue 也是只能支持一种操作， <a href="https://www.sciencedirect.com/science/article/abs/pii/0196677480900152">1980
Bentley &amp; Saxe</a>
发明了用一种叫做binary-counting的技巧把只支持一种操作的数据结构变成支持插入和删除的，维护的时间加一个<span class="math inline">\(\log\)</span>； 为了消除掉这个<span class="math inline">\(\log\)</span>还需要使用 b-ary。
最终复杂度能达到<span class="math inline">\(O(n\log
m+m\log^{1+\epsilon}n)\)</span>
<h3 data-number="0.3.3" id="随机化版本"><span class="header-section-number">0.3.3</span> 随机化版本</h3>
<p></p>
<a href="https://users.cs.duke.edu/~pankaj/publications/papers/k-vor.pdf">AGARWAL
et al.</a>
<p></p>
对于<span class="math inline">\(\mathbb{R}^d\)</span>上的k-level<span class="citation" data-cites="Clarkson_1988">[<a href="#ref-Clarkson_1988" role="doc-biblioref">1</a>]</span>
证明了复杂度是<span class="math inline">\(\Theta(n^{\lfloor d/2
\rfloor}k^{\lceil d/2 \rceil})\)</span>，上面链接中二维平面k-level复杂度
是<span class="math inline">\(O(nk + n\alpha(n) \log n )\)</span>
应该在到目前为止随机化算法中worst case是最优的
<p></p>
<strong>upd Sep 2024</strong>. <a href="https://tmc.web.engr.illinois.edu/pub_kset.html" class="uri">https://tmc.web.engr.illinois.edu/pub_kset.html</a>
有很多k-level相关的问题和算法.
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-Clarkson_1988" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">K.L. Clarkson, Applications of random sampling
in computational geometry, II, in: <em>Proceedings of the Fourth Annual
Symposium on Computational Geometry - SCG ’88</em>, ACM Press,
Urbana-Champaign, Illinois, United States, 1988: pp. 1–11 <a href="https://doi.org/10.1145/73393.73394">10.1145/73393.73394</a>.</div>
</div>
</div>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source</a> on Github.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>